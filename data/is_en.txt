EduMIPS64 INSTRUCTION SET
=========================

Here's a quick reference guide to the EduMIPS64 Instruction Set. Some 
descriptions are taken from the MIPS64 Manual. Please let us know if it is a 
problem, and we will remove them.


AND Instruction

Syntax: AND rd, rs, rt 
Description: rd = rs and rt
Does a bitwise logical AND, the contents of GPR rs are combined 
with the contents of GPR rt in a bitwise logical AND operation.
The result is placed into GPR rd.
            
            
ANDI Instruction

Syntax: ANDI rt, rs, immediate
Description: rt = rs AND immediate
            Does a bitwise logical AND with a constant
            The 16-bit immediate is zero-extended to the left and combined 
            with the contents of GPR rs in a bitwise logical AND
            operation. The result is placed into GPR rt.
            
B Instruction

Syntax: B offset
Description: Jumps inconditionally to offset

BEQ Instruction

Syntax: BEQ rs, rt, offset
Description: if rs = rt then branch
            To compare GPRs then do a PC-relative conditional branch
            
BEQZ Instruction

Syntax: BEQZ rs, offset
Description: if rs == 0 then branch
            To test a GPR then do a PC-relative conditional branch
             
BGEZ Instruction

Syntax: BGEZ rs, offset
Description: if rs >= 0 then branch
            Does a PC-relative branch to offset if rs >= 0

BNE Instruction

Syntax: BNE rt, rs, immediate
Description: if rs != rt then branch
            To compare GPRs then do a PC-relative conditional branch
            
BNEZ Instruction

Syntax: BNEZ rs, offset
Description: if rs != 0 then branch  
            To test a GPR then do a PC-relative conditional branch
            
DADD Instruction

Syntax: DADD rd, rs, rt
Description: 
            To add 64-bit integers. If overflow occurs, then trap.
            
DADDI Instruction

Syntax: DADDI rt, rs, immediate
Description: 
            To add a constant to a 64-bit integer. If overflow occurs, then trap.

DADDU Instruction

Syntax: DADDU rd, rs, rt
Description: rd = rs + rt
            To add 64-bit integers
            The 64-bit doubleword value in GPR rt is added to the 64-bit value 
  		    in GPR rs and the 64-bit arithmetic result is placed into GPR rd.
  		    No Integer Overflow exception occurs under any circumstances.
            
DADDIU Instruction

Syntax: DADDIU rt, rs, immediate
Description: 
            To add a constant to a 64-bit integer
            The 16-bit signed immediate is added to the 64-bit value 
            in GPR rs and the 64-bit arithmetic result is placed into
            GPR rt. No Integer Overflow exception occurs under any circumstances.

DDIV Instruction

Syntax: DDIV rs, rt
Description: (LO, HI) = rs / rt
            To divide 64-bit signed integers
            The 64-bit doubleword in GPR rs is divided by the 64-bit 
            doubleword in GPR rt, treating both operands as signed values.
            The 64-bit quotient is placed into special register LO and the 
            64-bit remainder is placed into special register HI.
            No arithmetic exception occurs under any circumstances.
            
DMULT Instruction

Syntax: DMULT rs, rt
Description: (LO) = rs * rt
           To divide 64-bit signed integers
           The 64-bit doubleword value in GPR rt is multiplied by the 64-bit 
           value in GPR rs, treating both operands as signed values.
           
DSLL Instruction

Syntax: DSLL rd, rt, sa Doubleword shift left logical
Description: 
            To execute a left-shift of a doubleword by a fixed amount—0 to 31 bits
            The 64-bit doubleword contents of GPR rt are shifted left, 
            inserting zeros into the emptied bits; the result is placed in GPR rd. 
            The bit-shift amount in the range 0 to 31 is specified by sa.
            
DSLLV Instruction

Syntax: DSLLV rd, rs, rt
Description: 
            To execute a left-shift of a doubleword by a variable number of bits.
            The 64-bit doubleword contents of GPR rt are shifted left, inserting 
            zeros into the emptied bits; the result is placed in GPR rd. 
            
DSRA Instruction

Format: DSRA rd, rt, sa
Description: 
            To execute an arithmetic right-shift of a doubleword 
            by a fixed amount—0 to 31 bits.
            
DSRAV Instruction

ormat: DSRAV rd, rs, rt
Description: rd = rt >> rs (arithmetic)
            To execute an arithmetic right-shift of a doubleword by a variable number of bits
            The doubleword contents of GPR rt are shifted right, duplicating 
            the sign bit (63) into the emptied bits; the result is placed in GPR rd.
            
DSRL Instruction

Syntax: DSRL rd, rt, sa
Description: 
            To execute a logical right-shift of a doubleword by a fixed amount¾0 to 31 bits
            The doubleword contents of GPR rt are shifted right, inserting zeros 
            into the emptied bits; the result is placed in GPR rd.
            
DSRLV Instruction

Syntax:      DSRLV rd, rs, rt
Description: 
            To execute a logical right-shift of a doubleword by a variable number of bits
            The 64-bit doubleword contents of GPR rt are shifted right, inserting 
            zeros into the emptied bits; the result is placed in GPR rd. 
            
DSUB Instruction

Syntax: DSUB rd, rs, rt
Description: 
            To subtract 64-bit integers; trap on overflow
            The 64-bit doubleword value in GPR rt is subtracted from 
            the 64-bit value in GPR rs to produce a 64-bit result. 
            
DSUBU Instruction

Syntax: DSUBU rd, rs, rt
Description: 
            To subtract 64-bit integers;
            The 64-bit doubleword value in GPR rt is subtracted from 
            the 64-bit value in GPR rs and the 64-bit arithmetic result 
            is placed into GPR rd.
            
LH Instruction

Syntax: LH rt, offset(base)
Description: rt = memory[base+offset]
            To load a halfword from memory as a signed value.
            
LHU Instruction

Syntax: LHU rt, offset(base)
Description:  rt = memory[base+offset]    
            To load a halfword from memory as an unsigned value  
            
LUI Instruction

Format: LUI rt, immediate
Description:   
            The 16-bit immediate is shifted left 16 bits and concatenated 
            with 16 bits of low-order zeros. 
            
LW Instruction

Format: LW rt, offset(base)
Description:   rt = memory[base+offset]
            To load a word from memory as a signed value.
            
LWU Instruction

Syntax: LWU rt, offset(base)
Description:   rt = memory[base+offset]
            To load a word from memory as an unsigned value.
            
HALT Instruction

Syntax:    HALT
Description: 
            To terminate the program execution
            When an HALT instruction performs ID step, it notifies to CPU
            that all instructions in pipeline after HALT instruction must be
            ignored
Exceptions:   HaltException

J Instruction

Syntax: J targetJ
Description: 
            To branch within the current 256 MB-aligned region
            This is a PC-region branch (not PC-relative); the effective 
            target address is in the “current” 256 MB-aligned region.
            
JAL Instruction

Syntax: JAL target
Description: 
            To execute a procedure call within the current 256 MB-aligned region
            Place the return address link in GPR 31.  This is a 
            PC-region branch (not PC-relative).
            
JALR Instruction

Syntax: JALR rs
Description: 
            To execute a procedure call to an instruction address in a register
            Place the return address link in GPR rd. 
            
JR Instruction

Syntax: JR rs
Description: 
            To execute a branch to an instruction address in a register.
            
LB Instruction

Syntax: LB rt, offset(base)
Description: rt = memory[base+offset]
            To load a byte from memory as a signed value.
            
LBU Instruction

Syntax: LBU rt, offset(base)
Description: rt = memory[base+offset]
            To load a byte from memory as an unsigned value.
            
LD Instruction

Syntax: LD rt, offset(base)
Description: rt = memory[base+offset]
            To load a doubleword from memory. 
            
LH Instruction

Syntax: LH rt, offset(base)
Description: rt = memory[base+offset]
            To load a halfword from memory as a signed value.
            
LHU Instruction
            
Syntax: LHU rt, offset(base)
Description:  rt = memory[base+offset]    
            To load a halfword from memory as an unsigned value.

LUI Instruction

Syntax: LUI rt, rs, immediate
Description:   
            The 16-bit immediate is shifted left 16 bits and concatenated 
            with 16 bits of low-order zeros.
            
LW Instruction

Syntax:  LW rt, offset(base)
Description:   rt = memory[base+offset]
            To load a word from memory as a signed value.
            
LWU Instruction

Syntax: LWU rt, offset(base)
Description:   rt = memory[base+offset]
            To load a word from memory as an unsigned value.
            
MFHI Instruction

Syntax: MFHI rd
Description: rd = HI
            To copy the special purpose HI register to a GPR
            The contents of special register HI are loaded into GPR rd.
            
MFLO Instruction

Syntax: MFLO rd
Description: rd = LO
            To copy the special purpose LO register to a GPR.
            
MOVN Instruction

Syntax: MOVN rd, rs, rt  
Description: if rt != 0 then rd = rs
            If the value in GPR rt is not equal to zero, then the contents 
            of GPR rs are placed into GPR rd.
            
MOVZ Instruction

Syntax: MOVZ rd, rs, rt
Description: if rt = 0 then rd = rs
            If the value in GPR rt is equal to zero, then the contents 
            of GPR rs are placed into GPR rd.
            
NOP Instruction

Syntax: NOP
Description:
            Creating null spaces in the pipeline.

OR Instruction

Syntax:	OR rd, rs, rt
Description: rd = rs or rt 
            To do a bitwise logical OR
            The contents of GPR rs are combined with the contents of 
            GPR rt in a bitwise logical OR operation.
            
ORI Instruction

Syntax: ORI rt, rs, immediate
Description:   
            To do a bitwise logical OR with a constant.
            
SLTU Instruction

Syntax: SLT rd, rs, rt
Description: 
            Records the result of an unsigned less-than comparison
   		    (rs<rt) in the GPR rd. In case, an Integer Overflow 
   		    exception will not occours.
            
SW Instruction

Syntax: SW rt, offset(base)
Description: 
            Stores in memory a byte from memory i.e rt = memory[base+offset]
            adding the signed offset to base to form the final address.
            
XOR Instruction

Syntax: XOR rd, rs, rt
Description: rd = rs XOR rt
            Combine the contents of GPR rs and GPR rt in a bitwise
            logical Exclusive OR operation.
            
XORI Instruction

Syntax: XORI rt, rs, immediate
Description: rt = rs XOR immediate
             To do a bitwise logical Exclusive OR with a constant.
             
SB Instruction

Syntax: SB rt, offset(base)
Description: memory[base+offset] = rt
            Stores the least-significant 8 bit of rt in memory.
    
SD Instruction

Syntax: SD rt, offset(base)
Description: memory[base+offset] = rt
            The doubleword in rt is stored in memory.
            
SH Instruction

Syntax: SH rt, offset(base)
Description: memory[base+offset] = rt
            Stores the halfword in rt to memory.
    
SLT Instruction

Syntax: SLT rd, rs, rt
Description: rd = (rs < rt)
            Records the result of a less-than comparison.
            
SLTI Instruction

Syntax: SLTI rt, rs, immediate
Description: 
            Records the result of a less-than comparison with a constant.
            
SLTIU Instruction

Syntax: SLTIU rt, rs, immediate
Description: 
            Records the result of an unsigned less-than comparison with a constant
   	        comparing the contents of GPR rs and the sign-extended immediate as unsigned 
            and recording the result in GPR rt. If GPR rs is less than immediate, rt 
    		will be 1 i.e true, else rt will be 0 i.e false.
 	        

  		    


            
