

<html lang="zh-CN" data-content_root="./">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" /><meta name="viewport" content="width=device-width, initial-scale=1" />

    <title>浮点单元 &#8212; EduMIPS64 1.3.0 文档</title>
    <link rel="stylesheet" type="text/css" href="_static/pygments.css?v=fa44fd50" />
    <link rel="stylesheet" type="text/css" href="_static/epub.css?v=e4d0adb4" />
    <script src="_static/documentation_options.js?v=4ebe3ea6"></script>
    <script src="_static/doctools.js?v=9bcbadda"></script>
    <script src="_static/sphinx_highlight.js?v=dc90522c"></script>
    <script src="_static/translations.js?v=beaddf03"></script> 
  </head><body>

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            
  <section id="id1">
<h1>浮点单元<a class="headerlink" href="#id1" title="Link to this heading">¶</a></h1>
<p>本章 <a class="footnote-reference brackets" href="#id3" id="id2" role="doc-noteref"><span class="fn-bracket">[</span>1<span class="fn-bracket">]</span></a> 介绍 EduMIPS64 仿真的浮点运算单元（FPU）。</p>
<p>在第一段中，我们将介绍双倍格式、IEEE 754 标准中定义的特殊浮点数值以及浮点计算可能引发的异常情况。</p>
<p>第二段介绍 EduMIPS64 如何允许用户启用或禁用 IEEE 浮点陷阱。</p>
<p>第三段介绍如何在源程序中指定双精度数和特殊值。</p>
<p>在第四段中，我们将介绍 FPU 用来表示其状态的 FCSR 寄存器。它包含四舍五入、比较运算的布尔结果以及处理 IEEE 浮点异常的策略等信息。</p>
<p>在第五段，也是最后一段，我们将介绍 EduMIPS64 中实现的所有 MIPS64 浮点指令。</p>
<p>在开始讨论 FPU 之前，我们将浮点双精度数域定义为[-1.79E308,-4.94E-324] ⋃ {0} ⋃ [4.94E-324,1.79E308]。</p>
<aside class="footnote-list brackets">
<aside class="footnote brackets" id="id3" role="doc-footnote">
<span class="label"><span class="fn-bracket">[</span><a role="doc-backlink" href="#id2">1</a><span class="fn-bracket">]</span></span>
<p>本章是马西莫-特鲁比亚（Massimo Trubia）学士学位论文 &quot;Progetto e implementazione di un modello di Floating Point Unit per un simulatore di CPU MIPS64 &quot;的一部分。</p>
</aside>
</aside>
<section id="special-values">
<span id="id4"></span><h2>特殊价值<a class="headerlink" href="#special-values" title="Link to this heading">¶</a></h2>
<p>浮点运算允许程序员选择在进行无效运算时是否停止计算。在这种情况下，零与零之间的除法或负数的平方根等运算必须产生一个结果，而这个结果如果不是数字（NaN），就会被视为不同的结果。</p>
<section id="nan">
<span id="id5"></span><h3>NaN 或无效操作<a class="headerlink" href="#nan" title="Link to this heading">¶</a></h3>
<p>IEEE 浮点运算标准（IEEE 754）规定，无效的运算操作可以在程序运行时发出错误信号（使用 IEEE 异常**无效操作**的陷阱），
或者返回特殊值 QNan（退出非数值）。另一个 NaN 值是 SNan（Signalling Not a Number），一旦检测到它是操作数之一，
就会无条件地引发相同的陷阱。这个值在应用程序中很少使用，历史上一直用于初始化变量。</p>
</section>
<section id="zeroes">
<span id="id6"></span><h3>零或下溢<a class="headerlink" href="#zeroes" title="Link to this heading">¶</a></h3>
<p>该标准定义的另一个特殊值是零。由于 double 格式的域中不包含零，因此它被视为一个特殊值。
零值有正零值和负零值两种：前者用于表示负数∈ ]-4.94E-324,0[) 时，并且需要一个结果（而不是允许**下溢**陷阱）；
后者用于表示的数字∈ [0,4.94E-324[]时，并且禁止下溢陷阱。</p>
</section>
<section id="infinites">
<span id="id7"></span><h3>无穷大还是溢出<a class="headerlink" href="#infinites" title="Link to this heading">¶</a></h3>
<p>当程序试图表示一个绝对值极大的数值（∈ ]-∞,-1.79E308[ ⋃ ]1.79E308,+∞[），而这个数值超出了双数值的范围时，CPU 会返回 -∞ 或 +∞。另一种方法是触发异常**溢出**条件陷阱。</p>
<p>在除以零的情况下，也可以返回无穷小数值；在这种情况下，无穷小数值的符号由零的符号和红利的符号的乘积给出。除以零**的陷阱也会出现。</p>
</section>
</section>
<section id="exception-configuration">
<span id="id8"></span><h2>异常配置<a class="headerlink" href="#exception-configuration" title="Link to this heading">¶</a></h2>
<p>EduMIPS64 允许用户通过 <em>配置</em> → <em>设置</em> 窗口中的 <em>FPU 异常</em> 选项卡，启用或禁用 5 个 IEEE 异常中 4 个的陷阱。
如果禁用了其中任何一个，将返回相应的特殊值（如 <a class="reference internal" href="#special-values"><span class="std std-ref">特殊价值</span></a> 中所述）。</p>
</section>
<section id="double">
<span id="double-directive"></span><h2>.double 指令<a class="headerlink" href="#double" title="Link to this heading">¶</a></h2>
<p><code class="docutils literal notranslate"><span class="pre">.double</span></code> 指令必须在源文件的 <code class="docutils literal notranslate"><span class="pre">.data</span></code> 部分使用，它允许为一个 <em>double</em> 值分配一个内存单元。</p>
<p>该指令有两种使用方式:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>变量名：.double double_number
变量名：.double 关键字
</pre></div>
</div>
<p>其中，<code class="docutils literal notranslate"><span class="pre">double_number</span></code> 可以用扩展符号（<code class="docutils literal notranslate"><span class="pre">1.0,0.003</span></code>）或科学符号（<cite>3.7E-12,0.5E32</cite>）表示。
关键字``可以是``POSITIVEINFINITY``、<code class="docutils literal notranslate"><span class="pre">NEGATIVEINFINITY</span></code>、<code class="docutils literal notranslate"><span class="pre">POSITIVEZERO</span></code>、<code class="docutils literal notranslate"><span class="pre">NEGATIVEZERO</span></code>、<cite>SNAN``和`QNAN`</cite>，
因此可以直接在内存中插入特殊值。</p>
</section>
<section id="fcsr">
<h2>FCSR 寄存器<a class="headerlink" href="#fcsr" title="Link to this heading">¶</a></h2>
<p>FCSR（浮点控制状态寄存器）是控制 FPU 多个功能方面的寄存器。它的长度为 32 位，在统计窗口中表示。</p>
<p><strong>FCC</strong> 字段宽 8 位，从 0 到 7。条件指令（<code class="docutils literal notranslate"><span class="pre">C.EQ.D,C.LT.D</span></code>）使用它来保存两个寄存器之间比较的布尔结果。</p>
<p>Cause、Enables 和 Flag 字段用于处理 <a class="reference internal" href="#special-values"><span class="std std-ref">特殊价值</span></a> 中描述的 IEEE 异常动态。每个字段由 5 个位组成，分别是 V（无效操作）、Z（除以零）、O（溢出）、U（下溢）和 I（不精确）；后者尚未使用。</p>
<p>如果在程序执行过程中出现相应的 IEEE 异常，<strong>Clause</strong> 字段位将被置位。</p>
<p>启用**字段位通过配置窗口设置，显示启用陷阱的 IEEE 异常。</p>
<p><strong>Flag</strong> 字段显示已发生的异常，但由于陷阱未针对该异常启用，因此返回了特殊值（ <a class="reference internal" href="#special-values"><span class="std std-ref">特殊价值</span></a> 中描述的特殊值）。</p>
<p><strong>RM</strong> 字段描述了当前使用的将浮点数转换为整数的舍入方法（请参阅 &quot;CVT.L.D &quot;指令的描述）。</p>
</section>
<section id="id9">
<h2>指令集<a class="headerlink" href="#id9" title="Link to this heading">¶</a></h2>
<p>本节介绍 EduMIPS64 实现的 MIPS64 FPU 指令；它们按字母顺序排列。指令执行的操作使用以下符号描述：第 i 个存储单元表示为 <code class="docutils literal notranslate"><span class="pre">memory[i]</span></code>，FCSR 寄存器的 FCC 字段表示为 <code class="docutils literal notranslate"><span class="pre">FCSR_FCC[cc]</span></code>， <code class="docutils literal notranslate"><span class="pre">cc</span></code> ∈ [0,7]。</p>
<p>在某些指令中，为了避免歧义，寄存器被表示为 <code class="docutils literal notranslate"><span class="pre">GPR[i]</span></code> 和 <code class="docutils literal notranslate"><span class="pre">FPR[i]</span></code>, <code class="docutils literal notranslate"><span class="pre">i</span></code> ∈ [0,31]，但在大多数情况下，我们只使用 <code class="docutils literal notranslate"><span class="pre">rx</span></code> 或 <code class="docutils literal notranslate"><span class="pre">fx</span></code> 符号，其中 <code class="docutils literal notranslate"><span class="pre">x``∈</span> <span class="pre">{d,s,t}。三个字母用来表示每个寄存器的用途（目的寄存器、源寄存器、第三寄存器）。最后，转换操作返回的值用以下符号表示：``convert_conversiontype(register[,rounding_type])</span></code>、
其中 <code class="docutils literal notranslate"><span class="pre">rounding_type</span></code> 参数是可选的。</p>
<p>有关 FPU 指令的一些示例，请访问 <code class="docutils literal notranslate"><span class="pre">http://www.edumips.org/attachment/wiki/Upload/FPUMaxSamples.rar</span></code>。</p>
<ul>
<li><p><cite>ADD.D fd, fs, ft</cite></p>
<p><em>描述</em>： <cite>fd =fs+ft</cite>。</p>
<p><em>异常</em>： 如果结果无法根据 IEEE 754 表示，将产生溢出和下溢陷阱。如果fs或ft包含QNaN或SNan，或者执行了无效操作（+∞ - ∞），则会产生无效操作。</p>
</li>
<li><p><cite>BC1F cc, offset</cite>.</p>
<p><em>描述</em>： <cite>if FCSR_FCC[cc] == 0 then branch</cite>.</p>
<p>如果 <code class="docutils literal notranslate"><span class="pre">FCSR_FCC[cc]</span></code> 为 false，则执行 PC 相关分支。</p>
<p><em>示例</em>:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">C</span><span class="o">.</span><span class="n">EQ</span><span class="o">.</span><span class="n">D</span> <span class="mi">7</span><span class="p">,</span><span class="n">f1</span><span class="p">,</span><span class="n">f2</span>
<span class="n">BC1F</span> <span class="mi">7</span><span class="p">,</span><span class="n">label</span>
</pre></div>
</div>
<p>在本例中，<code class="docutils literal notranslate"><span class="pre">C.EQ.D</span></code> 检查``f1``和``f2``是否相等，并将比较结果写入 FCSR 寄存器 FCC 字段的第 7 位。之后，如果比较结果为 0（假），<cite>BC1F`</cite> 将跳转到`label`。</p>
</li>
<li><p><cite>BC1T cc, offset</cite></p>
<p><em>描述</em>： <cite>if FCSR_FCC[cc] == 1 then branch`</cite>.</p>
<p>如果 <code class="docutils literal notranslate"><span class="pre">FCSR_FCC[cc]</span></code> 为真，则执行 PC 相关分支。</p>
<p><em>示例</em>:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">C</span><span class="o">.</span><span class="n">EQ</span><span class="o">.</span><span class="n">D</span> <span class="mi">7</span><span class="p">,</span><span class="n">f1</span><span class="p">,</span><span class="n">f2</span>
<span class="n">BC1T</span> <span class="mi">7</span><span class="p">,</span><span class="n">label</span>
</pre></div>
</div>
<p>在本例中，<code class="docutils literal notranslate"><span class="pre">C.EQ.D</span></code> 检查``f1``和``f2``是否相等，并将比较结果写入 FCSR 寄存器 FCC 字段的第 7 位。之后，如果比较结果为 1（假），则 <code class="docutils literal notranslate"><span class="pre">BC1F</span></code> 跳转到 <code class="docutils literal notranslate"><span class="pre">label</span></code> 。</p>
</li>
<li><p><cite>C.EQ.D cc, fs, ft</cite>.</p>
<p><em>描述</em>： <cite>FCSR_FCC[cc] = (fs==ft)`</cite></p>
<p>检查 <cite>fs</cite> 是否等于 <cite>ft</cite>，并将比较结果保存在 <cite>FCSR_FCC[cc]</cite> 中。请参阅 <code class="docutils literal notranslate"><span class="pre">BC1T</span></code>, <code class="docutils literal notranslate"><span class="pre">BC1F</span></code> 的示例。</p>
<p><em>异常</em>： 如果 <code class="docutils literal notranslate"><span class="pre">fs</span></code> 或 <code class="docutils literal notranslate"><span class="pre">ft</span></code> 包含 QNaN（如果启用则触发陷阱） o SNaN（总是触发陷阱），则可能抛出无效操作。</p>
</li>
<li><p><cite>C.LT.D cc,fs,ft</cite>。</p>
<p><em>描述</em>： <cite>FCSR_FCC[cc] = (fs&lt;ft)`</cite></p>
<p>检查 <cite>fs</cite> 是否小于 <cite>ft</cite>，并将比较结果保存在 <cite>FCSR_FCC[cc]</cite>。</p>
<p><em>示例</em>:：</p>
<blockquote>
<div><p>C.LT.D 2,f1,f2
BC1T 2,target</p>
</div></blockquote>
<p>在本例中，<cite>C.LT.D`</cite> 检查 <cite>f1</cite> 是否小于 <cite>f2</cite>，并将比较结果保存在 FCSR 寄存器 FCC 字段的第二位。之后，如果 <code class="docutils literal notranslate"><span class="pre">BC1T</span></code> 位设置为 1，则跳转到 <code class="docutils literal notranslate"><span class="pre">target</span></code> 位。</p>
<p><em>异常</em>： 如果 <code class="docutils literal notranslate"><span class="pre">fs</span></code> 或 <code class="docutils literal notranslate"><span class="pre">ft</span></code> 包含 QNaN（陷阱启用时触发） o SNaN（陷阱总是触发），则会抛出无效操作。</p>
</li>
<li><p><cite>CVT.D.L fd,fs</cite>。</p>
<p><em>描述</em>： <cite>fd = convert_longToDouble(fs)`</cite></p>
<p>将 long 转换为 double。</p>
<p><em>示例</em>:：</p>
<blockquote>
<div><p>DMTC1 r6,f5
CVT.D.L f5,f5</p>
</div></blockquote>
<p>在此示例中，<cite>DMTC1`</cite> 将 GPR r6 的值复制到 FPR f5；然后，<cite>CVT.D.L`</cite> 将存储在 f5 中的值从 long 转换为 double。例如，如果 r6 包含值 52，在执行 <code class="docutils literal notranslate"><span class="pre">DMTC1</span></code> 之后，52 的二进制表示将被复制到 f5。在执行 <code class="docutils literal notranslate"><span class="pre">CVT.D.L</span></code> 之后，f5 包含 52.0 的 IEEE 754 表示。</p>
<p><em>异常：</em> 如果 fs 包含 QNaN、SNaN 或无限值，则会抛出无效操作。</p>
</li>
<li><p><cite>CVT.D.W fd,fs</cite>。</p>
<p><em>描述：</em> <code class="docutils literal notranslate"><span class="pre">fd</span> <span class="pre">=</span> <span class="pre">convert_IntToDouble(fs)</span></code></p>
<p>将 int 转换为 double。</p>
<p><em>示例</em>:：</p>
<blockquote>
<div><p>MTC1 r6,f5
CVT.D.W f5,f5</p>
</div></blockquote>
<p>在本例中，<code class="docutils literal notranslate"><span class="pre">MTC1</span></code> 将 GPR r6 的低 32 位复制到 FPR f5 中。然后，<code class="docutils literal notranslate"><span class="pre">CVT.D.W</span></code> 读取 f5 作为 int，并将其转换为 double。</p>
<p>如果我们有 <code class="docutils literal notranslate"><span class="pre">r6=0xAAAAAAAABBBBBBBB</span></code> ，在执行 <code class="docutils literal notranslate"><span class="pre">MTC1</span></code> 后，我们会得到 <code class="docutils literal notranslate"><span class="pre">f5=0xXXXXXXXXBBBBBB</span></code> ；其上 32 位（<code class="docutils literal notranslate"><span class="pre">XX..X</span></code>）现在是未定义的（未被覆盖）。CVT.D.W``将 f5 解释为 int (<code class="docutils literal notranslate"><span class="pre">f5=-1145324613</span></code>) 并转换为 double (<code class="docutils literal notranslate"><span class="pre">f5=0xC1D11111400000</span> <span class="pre">=-1.145324613E9</span></code>).</p>
<p><em>异常：</em> 如果 fs 包含 QNaN、SNaN 或无限值，则会抛出无效操作。</p>
</li>
<li><p><cite>CVT.L.D fd,fs</cite></p>
<p><em>描述：</em> <code class="docutils literal notranslate"><span class="pre">fd</span> <span class="pre">=</span> <span class="pre">convert_doubleToLong(fs,</span> <span class="pre">CurrentRoundingMode)</span></code></p>
<p>将 double 转换为 long，在转换前进行四舍五入。</p>
<p><em>示例</em>:：</p>
<blockquote>
<div><p>CVT.L.D f5,f5
DMFC1 r6,f5</p>
</div></blockquote>
<p><cite>CVT.L.D</cite> 将 f5 中的 double 值转换为 long 值；然后 &quot;DMFC1 &quot;将 f5 复制到 r6；此操作的结果取决于当前的舍入模式，可在 &quot;配置 &quot;* → &quot;设置 &quot;* 窗口的 &quot;<em>FPU 舍入 &quot;</em> 选项卡中进行设置。</p>
</li>
</ul>
<table class="docutils align-default" id="id10">
<caption><span class="caption-text">四舍五入示例</span><a class="headerlink" href="#id10" title="Link to this table">¶</a></caption>
<thead>
<tr class="row-odd"><th class="head"><p>Tipo</p></th>
<th class="head"><p>RM field</p></th>
<th class="head"><p>f5 register</p></th>
<th class="head"><p>r6 register</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>To nearest</p></td>
<td><p>0</p></td>
<td><p>6.4</p></td>
<td><p>6</p></td>
</tr>
<tr class="row-odd"><td><p>To nearest</p></td>
<td><p>0</p></td>
<td><p>6.8</p></td>
<td><p>7</p></td>
</tr>
<tr class="row-even"><td><p>To nearest</p></td>
<td><p>0</p></td>
<td><p>6.5</p></td>
<td><p>6 (to even)</p></td>
</tr>
<tr class="row-odd"><td><p>To nearest</p></td>
<td><p>0</p></td>
<td><p>7.5</p></td>
<td><p>8 (to even)</p></td>
</tr>
<tr class="row-even"><td><p>Towards  0</p></td>
<td><p>1</p></td>
<td><p>7.1</p></td>
<td><p>7</p></td>
</tr>
<tr class="row-odd"><td><p>Towards  0</p></td>
<td><p>1</p></td>
<td><p>-2.3</p></td>
<td><p>-2</p></td>
</tr>
<tr class="row-even"><td><p>Towards  ∞</p></td>
<td><p>2</p></td>
<td><p>4.2</p></td>
<td><p>5</p></td>
</tr>
<tr class="row-odd"><td><p>Towards  ∞</p></td>
<td><p>2</p></td>
<td><p>-3.9</p></td>
<td><p>-3</p></td>
</tr>
<tr class="row-even"><td><p>Towards -∞</p></td>
<td><p>3</p></td>
<td><p>4.2</p></td>
<td><p>4</p></td>
</tr>
<tr class="row-odd"><td><p>Towards -∞</p></td>
<td><p>3</p></td>
<td><p>-3.9</p></td>
<td><p>-4</p></td>
</tr>
</tbody>
</table>
<ul>
<li><p><cite>CVT.W.D fd, fs</cite></p>
<p><em>描述：</em> <code class="docutils literal notranslate"><span class="pre">fd</span> <span class="pre">=</span> <span class="pre">convert_DoubleToInt(fs,</span> <span class="pre">CurrentRoundingMode)</span></code></p>
<p>使用当前舍入模式将 double 转换为 int。</p>
<p><em>异常：</em> 如果 fs 包含一个无限值、任何 NaN 或结果超出有符号 int 域 [-2 <sup>63</sup>, 2 <sup>63</sup> -1] 则会抛出无效操作。</p>
</li>
<li><p><cite>DIV.D fd, fs, ft</cite></p>
<p><em>描述：</em> <cite>fd = fsdiv ft</cite></p>
<p><em>异常：</em> 如果结果不能用 IEEE 754 标准表示，则会出现溢出或下溢。如果fs或ft包含QNaN或SNan，或者执行了无效操作（0div0,∞ div ∞），则会出现无效操作。如果试图用非 QNaN 或 SNaN 的红利除以零，则会出现除以零的提示。</p>
</li>
<li><p><cite>DMFC1 rt,fs</cite>.</p>
<p><em>描述：</em> <cite>rt = fs</cite></p>
<p>将 FPR fs 按位复制到 GPR rt 中。</p>
</li>
<li><p><cite>DMTC1 rt, fs</cite></p>
<p><em>描述：</em> <code class="docutils literal notranslate"><span class="pre">fs</span> <span class="pre">=</span> <span class="pre">rt</span></code></p>
<p>将 GPR rt 按位复制到 FPR fs 中。</p>
</li>
<li><p><cite>L.D ft, offset(base)</cite></p>
<p><em>描述：</em> <cite>ft = memory[GPR[base] + offset]`</cite></p>
<p>从内存中加载一个双字，并将其存储在 ft 中。</p>
</li>
</ul>
<p>注： <cite>L.D</cite> 不存在于 MIPS64 ISA 中，它是 <cite>LDC1</cite> 的别名，存在于 EduMIPS64 中，以便与 WinMIPS64 兼容。</p>
<ul>
<li><p>LDC1 ft, offset(base)`</p>
<p><em>描述：</em> <code class="docutils literal notranslate"><span class="pre">memory[GPR[base]</span> <span class="pre">+</span> <span class="pre">offset]</span></code></p>
<p>从内存中加载一个双字，并将其存储在 ft 中。</p>
</li>
<li><p><cite>LWC1 ft, offset(base)</cite></p>
<p><em>描述：</em> <cite>ft = memory[GPR[base] + offset]`</cite></p>
<p>从内存中加载一个字并将其存储在 ft 中。</p>
</li>
<li><p><cite>MFC1 rt,fs</cite></p>
<p><em>描述：</em> <code class="docutils literal notranslate"><span class="pre">rt</span> <span class="pre">=</span> <span class="pre">readInt(fs)</span></code></p>
<p>读取 fs FPR 的 int 值，并将其写入 rt GPR 的 long 值。
<em>示例</em>:：</p>
<blockquote>
<div><p>MFC1 r6,f5
SD r6,mem(R0)</p>
</div></blockquote>
<p>让 <code class="docutils literal notranslate"><span class="pre">f5=0xAAAAAAAABBBBBB</span></code>; <code class="docutils literal notranslate"><span class="pre">MFC1</span></code> 读取 f5 作为 int（低 32 位），将 <code class="docutils literal notranslate"><span class="pre">BBBBBBBB</span></code> 解释为 <code class="docutils literal notranslate"><span class="pre">-1145324613</span></code>，并将值写入 f6（64 位）。执行``MFC1``后，<code class="docutils literal notranslate"><span class="pre">r6=0xFFFFFFFFBBBBBBBB=-1145324613</span></code>。
因此，由于 r6 中的符号被扩展，<cite>SD`</cite> 指令将向内存写入一个具有此值的双字。</p>
</li>
<li><p><cite>MOVF.D fd, fs, cc</cite></p>
<p><em>描述：</em> <code class="docutils literal notranslate"><span class="pre">if</span> <span class="pre">FCSR_FCC[cc]</span> <span class="pre">==</span> <span class="pre">0</span> <span class="pre">then</span> <span class="pre">fd=fs</span></code></p>
<p>如果 FCSR_FCC[cc] 为假，则将 fs 复制到 fd。</p>
</li>
<li><p><cite>MOVT.D fd, fs, cc</cite></p>
<p><em>说明：</em> <code class="docutils literal notranslate"><span class="pre">if</span> <span class="pre">FCSR_FCC[cc]</span> <span class="pre">==</span> <span class="pre">1</span> <span class="pre">then</span> <span class="pre">fd=fs</span></code></p>
<p>如果 FCSR_FCC[cc] 为真，则将 fs 复制到 fd。</p>
</li>
<li><p><cite>MOV.D fd,fs</cite></p>
<p><em>描述：</em> <cite>fd = fs</cite></p>
<p>将 fs 复制到 fd。</p>
</li>
</ul>
<p><cite>MOVN.D fd, fs, rt</cite></p>
<blockquote>
<div><p><em>描述：</em> <code class="docutils literal notranslate"><span class="pre">if</span> <span class="pre">rt</span> <span class="pre">!=</span> <span class="pre">0</span> <span class="pre">then</span> <span class="pre">fd=fs</span></code></p>
<p>如果 rt 不为零，则将 fs 复制到 fd。</p>
</div></blockquote>
<ul>
<li><p><cite>MOVZ.D fd, fs, rt</cite></p>
<p><em>说明：</em> <code class="docutils literal notranslate"><span class="pre">if</span> <span class="pre">rt</span> <span class="pre">==</span> <span class="pre">0</span> <span class="pre">then</span> <span class="pre">fd=fs</span></code></p>
<p>如果 rt 等于零，则将 fs 复制到 fd。</p>
</li>
</ul>
<ul>
<li><p>MTC1 rt, fs</p>
<p><em>描述：</em> fs = rt <sub>0..31</sub></p>
<p>将 rt 的低 32 位复制到 fs。</p>
<p><em>示例</em>:：</p>
<blockquote>
<div><p>MTC1 r6,f5</p>
</div></blockquote>
<p>让 <code class="docutils literal notranslate"><span class="pre">r5=0xAAAAAAABBBBBBB``B</span></code>; <code class="docutils literal notranslate"><span class="pre">MTC1</span></code> 读取 r5 的低 32 位，并将其复制到 f5 的低 32 位。 f5 的高 32 位不会被覆盖。</p>
</li>
<li><p><cite>MUL.D fd, fs, ft</cite></p>
<p><em>描述：</em> <code class="docutils literal notranslate"><span class="pre">fd</span> <span class="pre">=fs×ft</span></code>。</p>
<p><em>异常：</em> 如果结果不能用 IEEE 754 标准表示，则会出现溢出或下溢。如果 fs 或 ft 包含 QNaN 或 SNan，或执行了无效操作（乘以 ∞ 或 BY QNaN），则会出现无效操作。</p>
</li>
<li><p><cite>S.D ft，offset(base)</cite>。</p>
<p><em>描述：</em> <cite>memory[base+offset] = ft`</cite></p>
<p>将 ft 复制到内存中。</p>
</li>
</ul>
<p>注意：MIPS64 ISA 中没有`S.D`，它是`SDC1`的别名，EduMIPS64 中有`SDC1`，以便与 WinMIPS64 兼容。</p>
<ul>
<li><p><cite>SDC1 ft, offset(base)</cite></p>
<p><em>描述：</em> <code class="docutils literal notranslate"><span class="pre">memory[base+offset]</span> <span class="pre">=</span> <span class="pre">ft</span></code></p>
<p>将 ft 复制到内存。</p>
</li>
<li><p><cite>SUB.D fd, fs, ft</cite></p>
<p><em>描述：</em> <code class="docutils literal notranslate"><span class="pre">fd</span> <span class="pre">=</span> <span class="pre">fs-ft</span></code></p>
<p><em>异常</em>： 如果结果无法根据 IEEE 753 表示，则会产生溢出和下溢陷阱。如果fs或ft包含QNaN或SNan，或者执行了无效操作（+∞ - ∞），则会产生无效操作。</p>
</li>
<li><p><cite>SWC1 ft, offset(base)</cite></p>
<p><em>描述：</em> <code class="docutils literal notranslate"><span class="pre">memory[base+offset]</span> <span class="pre">=</span> <span class="pre">ft</span></code></p>
<p>将 ft 的低 32 位复制到内存中。</p>
</li>
</ul>
</section>
</section>


            <div class="clearer"></div>
          </div>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
  </body>
</html>