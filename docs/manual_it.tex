\documentclass[12pt]{report}
\usepackage{verbatim}
\usepackage{amsfonts}
\usepackage{indentfirst}
\usepackage{makeidx}
\usepackage{listings}
\usepackage{fancyhdr}
\usepackage[italian]{babel}
\newcommand{\EM}{EduMIPS64}
\newcommand{\EV}{0.5}
\newcommand{\MS}{MIPS64}
\newcommand{\SC}{\texttt{SYSCALL}}
\newcommand{\WARN}{\textbf{ATTENZIONE:} Questa \`{e} un'istruzione deprecated, che
non appartiene al repertorio delle istruzioni \MS{}, ma \`{e} stata inclusa nel set di
istruzioni per mantenere la compatibilit\`{a} con altri simulatori.}
\newcommand{\MISN}{\textbf{NB:} La 'U' dell'istruzione sta per 'unsigned'; tuttavia questo \`{e} 
un nome equivoco, perch\'{e} l'operazione considera i valori con segno. La sua caratteristica \`{e} 
quella di non lanciare eccezioni (nemmeno in caso di overflow).}
\newcommand{\OF}{\textbf{NB:} Questo listato prevede che il registro \$s2 contenga il file descriptor
relativo al file da utilizzare (se utilizzate questo listato copia-incollate il codice del listato \ref{code:syscall1} prima di questo).}

% Per avere il bold typewriter
\DeclareFontShape{OT1}{cmtt}{bx}{n}{ <5><6><7><8><9><10><10.95><12><14.4><17.28><20.74><24.88>cmttb10}{}

\lstdefinestyle{mips}{
	language=java,
	numbers=left,
	basicstyle=\small,
	keywordstyle=\bfseries,
	identifierstyle=\ttfamily,
	stringstyle=\ttfamily,
	captionpos=b,
	abovecaptionskip=15pt,
	showstringspaces=false
}
\lstdefinestyle{java}{
	language=java,
	numbers=left,
	basicstyle=\small,
	keywordstyle=\bfseries,
	identifierstyle=\ttfamily,
	stringstyle=\ttfamily,
	captionpos=b,
	abovecaptionskip=15pt,
	showstringspaces=false
}

\usepackage{subfigure}
\usepackage[top=5.3cm, bottom=2cm, left=4cm, right=3cm]{geometry}

\makeindex

\author{Andrea Spadaccini\\Traduzione italiana di Simona Ullo}
\title{Manuale Utente EduMIPS64 \EV}

\hyphenation{mo-di-fica}
\hyphenation{vi-sua-liz-zan-do}
\hyphenation{dia-lo-go}

\begin{document}
\setlength{\baselineskip}{1.60\baselineskip} % interlinea
% TODO: prettier titlepage
%\begin{titlepage}
%EduMIPS64
%\end{titlepage}
%\maketitle
% START OF TITLEPAGE

\newlength{\centeroffset}
\setlength{\centeroffset}{-0.5\oddsidemargin}
\addtolength{\centeroffset}{0.5\evensidemargin}
%\addtolength{\textwidth}{-\centeroffset}
\thispagestyle{empty}
\vspace*{\stretch{1}}
\noindent\hspace*{\centeroffset}\makebox[0pt][l]{\begin{minipage}{\textwidth}
\flushright
{\Huge\bfseries Manuale utente di EduMIPS64
}
\noindent\rule[-1ex]{\textwidth}{5pt}\\[2.5ex]
\end{minipage}}

\vspace{\stretch{1}}
\noindent\hspace*{\centeroffset}\makebox[0pt][l]{\begin{minipage}{\textwidth}
\flushright
{\bfseries 
di Andrea Spadaccini\\[1.5ex]
Traduzione italiana di Simona Ullo\\[3ex]
} 
Versione~1.1, 22 Aprile 2007
\end{minipage}}

%\addtolength{\textwidth}{\centeroffset}
\vspace{\stretch{2}}


\pagebreak
% END OF TITLEPAGE

\tableofcontents
\listoftables
\lstlistoflistings
\chapter{Introduzione}
La prima sezione riguarda il formato dei file sorgente accettato dal simulatore,
descrivendo i tipi di dato e le direttive, oltre ai parametri da linea di comando.
Nella seconda sezione \`{e} presentata una panoramica del set di istruzioni  \MS{}
utilizzato da \EM{}, con tutti i parametri richiesti e le indicazioni per il loro utilizzo.
La terza sezione \`{e} una descrizione dell'interfaccia utente di \EM{}, 
che espone lo scopo di ciascuna finestra e di ciascun men\`{u}, insieme ad una descrizione 
delle finestre di configurazione, del Dinero frontend, del manuale e delle opzioni da linea di comando. 
%La quarta sezione contiene un esempio di utilizzo di \EM{}, 
%un pratico tutorial che vi guider\`{a} attraverso l'esecuzione di un semplice programma \MS{}.
Questo manuale si riferisce ad EduMIPS64 versione \EV{}

\chapter{Formato dei file sorgenti}
\EM{} si propone di seguire le convenzioni usate negli altri simulatori \MS{} e DLX, 
in modo tale da non creare confusione riguardante la sintassi per i vecchi utenti.

\section{Sezioni}
\index{.data}\index{.code}
All'interno di un file sorgente sono presenti due sezioni: quella dedicata ai \textbf{dati} 
e quella in cui \`{e} contenuto il \textbf{code}, introdotte rispettivamente dalle direttive \textbf{.data} e
\textbf{.code}. Nel listato~\ref{code:sample} \`{e} possibile vedere un semplice programma 
\EM{}.

Per distinguere le varie parti di ciascuna linea di codice, pu\`{o} essere utilizzata una qualunque combinazione di spazi e tabulazioni.

\begin{lstlisting}[caption={Esempio di codice \EM{}}, label={code:sample}, style={mips}]
; Questo e' un commento
        .data
label:  .word   15     ; Questo e' un commento in linea

        .code
        daddi   r1, r0, 0
        syscall 0
\end{lstlisting}

\index{commenti}\index{;}
I commenti possono essere introdotti utilizzando il carattere ``;'' qualsiasi
cosa venga scritta successivamente ad esso verr\`{a} ignorata.  Un commento
pu\`{o} quindi essere usato ``inline'' (dopo una direttiva) oppure in una riga a
s\`{e} stante.

\index{etichette} Le etichette possono essere usate nel codice per fare
riferimento ad una cella di memoria o ad un'istruzione.  Esse sono case
insensitive. Per ciascuna linea di codice pu\`{o} essere utilizzata un'unica
etichetta. Quest'ultima pu\`{o} essere inserita una o pi\`{u} righe al di sopra
dell'effettiva dichiarazione del dato o dell'istruzione, facendo in modo che non
ci sia nulla, eccetto commenti e linee vuote, tra l'etichetta stessa e la
dichiarazione. 

\subsection{La sezione \texttt{.data}}
\index{.data}
La sezione \textbf{data} contiene i comandi che specificano il modo in cui la
memoria deve essere riempita prima dell'inizio dell'esecuzione del programma. La
forma generale di un comando \texttt{.data} \`{e}:

\begin{center}
	\texttt{[etichetta:] \textbf{.tipoDiDato} valore1 [, valore2 [, ...]]}
\end{center}

\EM{} supporta diversi tipi di dato, che sono descritti nella tabella~\ref{table:datatypes}.

\index{tipi di dato}
\index{.byte}
\index{.word}
\index{.word16}
\index{.word32}
\index{.word64}
\begin{table}[!htb]
	\begin{centering}
		\begin{tabular}{lll}
			\hline
			\hline
			Tipo & Direttiva & Bit richiesti\\
			\hline
			Byte & \texttt{.byte} & 8\\
			Half word & \texttt{.word16} & 16\\
			Word & \texttt{.word32} & 32\\
			Double Word & \texttt{.word} o \texttt{.word64} & 64
		\end{tabular}
		\caption{Tipi di dato}
		\label{table:datatypes}
	\end{centering}
\end{table}

Dati di tipo doubleword possono essere introdotti sia dalla direttiva
\texttt{.word} che dalla direttiva \texttt{.word64}.

\index{array} Esiste una differenza sostanziale tra la dichiarazione di una lista di dati 
utilizzando un'unica direttiva oppure direttive multiple dello stesso tipo.
\EM{} inizia la scrittura a partire dalla successiva double word a 64 bit non appena 
trova un identificatore del tipo di dato, in tal modo la prima istruzione \texttt{.byte} 
del listato~\ref{code:data_array} inserir\`{a} i numeri 1, 2, 3 e 4 nello spazio di 4 byte, 
occupando 32 bit, mentre il codice delle successive quattro righe inserir\`{a} ciascun numero 
in una differente cella di memoria, occupando 32 byte, come specificato nella tabella~\ref{table:effect}.

\begin{lstlisting}[caption={Byte adiacenti}, label={code:data_array}, style={mips}]
	.data
	.byte	1, 2, 3, 4
	.byte	1
	.byte	2
	.byte	3
	.byte	4
\end{lstlisting}

Nella tabella~\ref{table:effect}, la memoria \`{e} rappresentata utilizzando celle di dimensione pari 
ad 1 byte e ciascuna riga \`{e} lunga 64 bit. L'indirizzo posto alla sinistra di ogni riga della tabella \`{e} 
riferito alla cella di memoria pi\`{u} a destra, che possiede l'indirizzo pi\`{u} basso rispetto alle otto celle in ciascuna linea.

\begin{table}[htb]
	\begin{centering}
		\begin{tabular}{r|c|c|c|c|c|c|c|c|}
			\cline{2-9}
			0 & 0 & 0 & 0 & 0 &4 & 3 &2 &1 \\
			\cline{2-9}
			8 & 0 & 0 & 0 & 0 &0 & 0 &0 &1 \\
			\cline{2-9}
			16 & 0 & 0 & 0 & 0 &0 & 0 &0 &2 \\
			\cline{2-9}
			24 & 0 & 0 & 0 & 0 &0 & 0 &0 &3 \\
			\cline{2-9}
			36 & 0 & 0 & 0 & 0 &0 & 0 &0 &4\\ 
			\cline{2-9}
		\end{tabular}
		\caption{Stato della memoria per il listato~\ref{code:data_array}}
		\label{table:effect}
	\end{centering}
\end{table}
Ci sono alcune direttive speciali che devono essere discusse: \texttt{.space}, 
\texttt{.ascii} e \texttt{.asciiz}.
\index{.space}
La direttiva \texttt{.space} \`{e} usata per lasciare dello spazio vuoto in memoria. 
Essa accetta un intero come parametro, che indica il numero di byte che devono essere lasciati liberi. 
Tale direttiva \`{e} utile quando \`{e} necessario conservare dello spazio in memoria per i risultati dei propri calcoli.

\index{.ascii}
La direttiva \texttt{.ascii} accetta stringhe contenenti un qualunque carattere ASCII, 
ed alcune ``sequenze di escape'', simili a quelle presenti nel linguaggio C, che sono descritte nella 
tabella~\ref{table:escaping}, ed inserisce tali stringhe in memoria.

\index{.asciiz}
La direttiva \texttt{.asciiz} si comporta esattamente come il comando \texttt{.ascii},
con la differenza che essa pone automaticamente alla fine della stringa un byte nullo.

\begin{table}[!htb]
	\begin{tabular}{lll}
		\hline
		\hline
		Sequenza di escape & Significato & Codifica ASCII\\
		\hline
		\texttt{$\backslash$0} & Byte nullo & 0\\
		\texttt{$\backslash$t} & Tabulazione orizzontale & 9\\
		\texttt{$\backslash$n} & Nuova linea & 10\\
		\texttt{$\backslash$}`` & Apici doppi & 34\\
		\texttt{$\backslash\backslash$} & Backslash & 92
	\end{tabular}
	\caption{Sequenze di escape}
	\label{table:escaping}
\end{table}

\subsection{La sezione \texttt{.code}}
\index{.code}
La sezione \textbf{code} contiene comandi che specificano come la memoria debba essere riempita 
quando il programma verr\`{a} eseguito. La forma generale di un comando \texttt{.code} \`{e}:

\index{sintassi!parametri istruzioni}
\begin{center}
	\texttt{[etichette:] \textbf{istruzione} [param1 [, param2 [, param3]]]}
\end{center}

\index{.text} pu\`{o} essere indicata anche con la direttiva \texttt{.text}.

Il numero e il tipo di parametri dipendono dall'istruzione stessa. 
%Please see table~\ref{table:segm-type} for the list of possible parameters.

Le istruzioni possono accettare tre tipi di parametri:
\begin{itemize}
	\item \textbf{Registri} un parametro di tipo registro \`e indicato da una
    ``r'' maiuscola o minuscola, o da un carattere ``\$'', a fianco del numero
    di registro (tra 0 e 31). Ad esempio, le scritture ``r4'', ``R4'' e ``\$4''
    identificano tutt'e tre il quarto registro;
	\item \textbf{Valori immediati} un valore immediato pu\`o essere un numero o
    un'etichetta; il numero pu\`o essere specificato in base 10 o in base 16. I
    numeri in base 10 sono inseriti semplicemente scrivendo il numero
    utilizzando l'usuale notazione decimale; i numeri in base 16 si inseriscono
    aggiungendo all'inizio del numero il prefisso ``0x'';
    \item \textbf{Indirizzi} un indirizzo \`e composto da un valore immediato
    seguito dal nome di un registro tra parentesi. Il valore del registro sar\`a
    usato come base, quello dell'immediato come offset.
\end{itemize}

La dimensione dei valori immediati \`{e} limitata al numero di bit disponibili
nella codifica associata all'istruzione. 

\`E possibile utilizzare gli alias standard MIPS per i primi 32 registri,
mettendo in coda ai prefissi standard per i registri (``r'', ``\$'', ``R'') uno
degli alias indicati in tabella~\ref{table:mips32-reg}

\index{registri}
\begin{table}[!htb]
	\begin{centering}
		\begin{tabular}{ll}
			\hline
			\hline
			Registro & Alias\\
			\hline
			0 & \texttt{zero}\\
			1 & \texttt{at}\\
			2 & \texttt{v0}\\
			3 & \texttt{v1}\\
			4 & \texttt{a0}\\
			5 & \texttt{a1}\\
			6 & \texttt{a2}\\
			7 & \texttt{a3}\\
			8 & \texttt{t0}\\
			9 & \texttt{t1}\\
			10 & \texttt{t2}\\
			11 & \texttt{t3}\\
			12 & \texttt{t4}\\
			13 & \texttt{t5}\\
			14 & \texttt{t6}\\
			15 & \texttt{t7}\\
			16 & \texttt{s0}\\
			17 & \texttt{s1}\\
			18 & \texttt{s2}\\
			19 & \texttt{s3}\\
			20 & \texttt{s4}\\
			21 & \texttt{s5}\\
			22 & \texttt{s6}\\
			23 & \texttt{s7}\\
			24 & \texttt{t8}\\
			25 & \texttt{t9}\\
			26 & \texttt{k0}\\
			27 & \texttt{k1}\\
			28 & \texttt{gp}\\
			29 & \texttt{sp}\\
			30 & \texttt{fp}\\
			31 & \texttt{ra}\\
		\end{tabular}
		\caption{Alias per i primi 32 registri}
		\label{table:mips32-reg}
	\end{centering}
\end{table}

%Please see~\cite{mips-2} for more details about how instruction are actually encoded.

Le istruzioni che possono essere utilizzate in questa sezione saranno discusse nella sezione~\ref{instructions}

\subsection{Il comando \texttt{\#include}}
I sorgenti possono includere il comando \texttt{\textbf{\#include} nomefile}, che
ha l'effetto di inserire, al posto della riga contenente questo comando, il
contenuto del file \texttt{nomefile}.
Questo comando \`e utile se si vogliono includere delle funzioni esterne, ed \`e
dotato di un algoritmo di rilevamento dei cicli, che impedisce di eseguire
inclusioni circolari tipo ``\texttt{\#include A.s}'' nel file \texttt{B.s} e
``\texttt{\#include B.s}'' nel file \texttt{A.s}.

\chapter{Il repertorio delle istruzioni}
\label{instructions}
\index{istruzioni}

In questa sezione verr\`{a} illustrato il repertorio delle istruzioni \MS{} riconosciute da \EM{}.
\`{E} possibile effettuare due differenti classificazioni: una basata sulla funzionalit\`{a} delle istruzioni e 
l'altra basata sul tipo di parametri.

% Please refer to Section~\ref{mipsis} for more informations about those classifications.

La prima classificazione suddivide le istruzioni in tre categorie: istruzioni ALU, istruzioni Load/Store, 
istruzioni di controllo del flusso. I prossimi tre paragrafi descriveranno ciascuna categoria e le istruzioni che vi appartengono.

Il quarto paragrafo descriver\`{a} le istruzioni che non rientrano in nessuna delle tre categorie sopraelencate.

%For a more complete \MS{} instruction set reference, please refer to~\cite{mips-2}.

\section{Istruzioni ALU}
L'unit\`{a} logico-aritmetica (ALU) fa parte dell'unit\`{a} esecutiva di una CPU ed assume il ruolo di esecuzione 
di operazioni logiche ed aritmetiche. Il gruppo di istruzioni ALU conterr\`{a} quindi quelle istruzioni 
che effettuano questo tipo di operazioni.

Le istruzioni ALU possono essere suddivise in due gruppi: \textbf{tipo R} e \textbf{tipo I}. 

\index{istruzioni!istruzioni ALU}
\index{LO}
\index{HI}
\index{registri!LO}
\index{registri!HI}
Quattro di esse utilizzano due registri speciali: LO e HI. Tali registri sono interni alla CPU ed \`{e} 
possibile accedere al loro valore mediante le istruzioni \texttt{MFLO} e \texttt{MFHI}.

Ecco la lista delle istruzioni ALU di tipo R.

\begin{itemize}
	\index{AND}
	\index{istruzioni!AND}
	\item \texttt{AND rd, rs, rt}\\
	Esegue un AND bit a bit tra rs ed rt, e pone il risultato in rd.
	
	\index{ADD}
	\index{instruzioni!ADD}
	\item \texttt{ADD rd, rs, rt}\\
	Somma il contenuto dei registri a 32-bit rs ed rt, considerandoli come valori con segno, e pone il risultato in rd.
	Lancia un eccezione in caso di overflow.

	\index{ADDU}
	\index{instruzioni!ADDU}
	\item \texttt{ADDU rd, rs, rt}\\
	Somma il contenuto dei registri a 32-bit rs ed rt, e pone il risultato in rd.
	Non si verificano eccezioni di overflow.
	\MISN{}

	\index{DADD}
	\index{istruzioni!DADD}
	\item \texttt{DADD rd, rs, rt}\\
	Somma il contenuto dei registri a 64-bit rs ed rt, considerandoli come valori con segno, e pone il risultato in rd.
	Lancia un eccezione in caso di overflow.

	\index{DADDU}
	\index{istruzioni!DADDU}
	\item \texttt{DADDU rd, rs, rt}\\
	Somma il contenuto dei registri a 64-bit rs ed rt, e pone il risultato in rd.
	Non si verificano eccezioni di overflow.
	\MISN{}

	\index{DDIV}
	\index{istruzioni!DDIV}
	\item \texttt{DDIV rs, rt}\\
	Esegue la divisione tra i registri a 64-bit rs ed rt, ponendo i 64-bit del quoziente
	in LO ed i 64-bit del resto in HI.

	\index{DDIVU}
	\index{istruzioni!DDIVU}
	\item \texttt{DDIVU rs, rt}\\
    	Esegue la divisione tra i registri a 64-bit rs ed rt, considerandoli come valori senza segno e
    	ponendo i 64-bit del quoziente in LO ed i 64-bit del resto in HI.

	\index{DIV}
	\index{istruzioni!DIV}
	\item \texttt{DIV rs, rt}\\
	Esegue la divisione tra i registri a 32-bit rs ed rt, ponendo i 32-bit del quoziente
	in LO ed i 32-bit del resto in HI.

	\index{DIVU}
	\index{istruzioni!DIVU}
	\item \texttt{DIVU rs, rt}\\
    	Esegue la divisione tra i registri a 32-bit rs ed rt, considerandoli come valori senza segno e
    	pone i 32-bit del quoziente in LO ed i 32-bit del resto in HI.
	
	\index{DMULT}
	\index{istruzioni!DMULT}
	\item \texttt{DMULT rs, rt}\\
	Esegue il prodotto tra i registri a 64-bit rs ed rt, ponendo i 64 bit bassi del risultato nel registro speciale LO
	e i 64 bit alti del risultato nel registro speciale HI.

	\index{DMULTU}
	\index{istruzioni!DMULTU}
	\item \texttt{DMULTU rs, rt}\\
	Esegue il prodotto tra i registri a 64-bit rs ed rt, considerandoli come valori senza segno e ponendo i 64 bit bassi
	del risultato nel registro speciale LO e i 64 bit alti del risultato nel registro speciale HI.

	\index{DSLL}
	\index{istruzioni!DSLL}
	\item \texttt{DSLL rd, rt, sa}\\
	Effettua uno shift verso sinistra del registro a 64-bit rt, di un numero di bit indicato nel valore immediato (positivo compreso tra 0 e 63) sa, 
	e pone il risultato in rd. I bit liberi vengono posti a zero.

	\index{DSLLV}
	\index{istruzioni!DSLLV}
	\item \texttt{DSLLV rd, rt, rs}\\
	Effettua uno shift verso sinistra del registro a 64-bit rt, di un numero di bit specificato nei 6 bit bassi del registro 
    rs che verr\`{a} letto come valore senza segno, e pone il risultato in rd. I bit liberi vengono posti a zero.

	\index{DSRA}
	\index{istruzioni!DSRA}
	\item \texttt{DSRA rd, rt, sa}\\
	Effettua uno shift verso destra del registro a 64-bit rt, di un numero di bit specificato nel valore senza segno immediato (positivo compreso tra 0 e 63) sa, 
	e pone il risultato in rd. I bit liberi vengono posti a zero se il bit pi\`{u} a sinistra di rs \`{e} zero, altrimenti vengono posti a uno.

	\index{DSRAV}
	\index{istruzioni!DSRAV}
	\item \texttt{DSRAV rd, rt, rs}\\
	Effettua uno shift verso destra del registro a 64-bit rt, di un numero di bit specificato nei 6 bit bassi del registro rs 
	 che verr\`{a} letto come valore senza segno,e pone il risultato in rd. 
	I bit liberi vengono posti a zero se il bit pi\`{u} a sinistra di rs \`{e} zero, altrimenti vengono posti a uno.

	\index{DSRL}
	\index{istruzioni!DSRL}
	\item \texttt{DSRL rd, rt, sa}\\
	Effettua uno shift verso destra del registro a 64-bit rt, di un numero di bit specificato nel valore immediato (positivo compreso tra 0 e 63) sa, 
	e pone il risultato in rd. I bit liberi vengono posti a zero.
	
	\index{DSRLV}
	\index{istruzioni!DSRLV}
	\item \texttt{DSRLV rd, rt, rs}\\
	Effettua uno shift verso destra del registro a 64-bit rt, di un numero di bit specificato nei 6 bit bassi del registro rs che verr\`{a} letto come valore senza segno, 
	e pone il risultato in rd. I bit liberi vengono posti a zero.

	\index{DSUB}
	\index{istruzioni!DSUB}
	\item \texttt{DSUB rd, rs, rt}\\
	Sottrae il valore del registro a 64-bit rt al valore del registro a 64-bit rs, considerandoli come valori con segno,
	e pone il risultato in rd. Lancia un eccezione in caso di overflow.

	\index{DSUBU}
	\index{istruzioni!DSUBU}
	\item \texttt{DSUBU rd, rs, rt}\\
	Sottrae il valore del registro a 64-bit rt al valore del registro a 64-bit rs, e pone il risultato in rd.
	Non si verificano eccezioni di overflow.
	\MISN{}

	\index{MFLO}
	\index{istruzioni!MFLO}
	\item \texttt{MFLO rd}\\
	Copia il contenuto del registro speciale LO in rd.

	\index{MFHI}
	\index{istruzioni!MFHI}
	\item \texttt{MFHI rd}\\
	Copia il contenuto del registro speciale HI in rd.

	\index{MOVN}
	\index{istruzioni!MOVN}
	\item \texttt{MOVN rd, rs, rt}\\
	Se rt \`{e} diverso da zero, copia il contenuto di rs in rd.
	
	\index{MOVZ}
	\index{istruzioni!MOVZ}
	\item \texttt{MOVZ rd, rs, rt}\\
	Se rt \`{e} uguale a zero, copia il contenuto di rs in rd.

	\index{MULT}
	\index{istruzioni!MULT}
	\item \texttt{MULT rs, rt}\\
	Esegue il prodotto tra i registri a 32-bit rs ed rt, ponendo i 32 bit bassi del risultato nel registro speciale LO
	e i 32 bit alti del risultato nel registro speciale HI.

	\index{MULTU}
	\index{istruzioni!MULTU}
	\item \texttt{MULTU rs, rt}\\
	Esegue il prodotto tra i registri a 32-bit rs ed rt, considerandoli come valori senza segno e ponendo i 32 bit 
	bassi del risultato nel registro speciale LO e i 32 bit alti del risultato nel registro speciale HI.
	
	\index{OR}
	\index{istruzioni!OR}
	\item \texttt{OR rd, rs, rt}\\
	Esegue un OR bit a bit tra rs ed rt, e pone il risultato in rd.

	\index{SLL}
	\index{istruzioni!SLL}
	\item \texttt{SLL rd, rt, sa}\\
	Effettua uno shift verso sinistra del registro a 32-bit rt, di un numero di bit indicati nel valore immediato (positivo compreso tra 0 e 63) sa, 
	e pone il risultato nel registro a 32-bit rd. I bit liberi vengono posti a zero.

	\index{SLLV}
	\index{istruzioni!SLLV}
	\item \texttt{SLLV rd, rt, rs}\\
	Effettua uno shift verso sinistra del registro a 32-bit rt, di un numero di bit specificato nei 5 bit bassi del registro rs che verr\`{a} letto come valore senza segno, 
	e pone il risultato nel registro a 32-bit rd. I bit liberi vengono posti a zero.

	\index{SRA}
	\index{istruzioni!SRA}
	\item \texttt{SRA rd, rt, sa}\\
	Effettua uno shift verso destra del registro a 32-bit rt, di un numero di bit specificato nel valore immediato (positivo compreso tra 0 e 63) sa, 
	e pone il risultato nel registro a 32-bit rd.
	I bit liberi vengono posti a zero se il bit pi\`{u} a sinistra di rs \`{e} zero, altrimenti vengono posti a uno.

	\index{SRAV}
	\index{istruzioni!SRAV}
	\item \texttt{SRAV rd, rt, rs}\\
	Effettua uno shift verso destra del registro a 32-bit rt, di un numero di bit specificato nei 5 bit bassi del registro rs che verr\`{a} letto come valore senza segno,
	e pone il risultato nel registro a 32-bit in rd. 
	I bit liberi vengono posti a zero se il bit pi\`{u} a sinistra di rs \`{e} zero, altrimenti vengono posti a uno.

	\index{SRL}
	\index{istruzioni!SRL}
	\item \texttt{SRL rd, rt, sa}\\
	Effettua uno shift verso destra del registro a 32-bit rt, di un numero di bit specificato nel valore immediato (positivo compreso tra 0 e 63) sa, 
	e pone il risultato nel registro a 32-bit rd. I bit liberi vengono posti a zero.
	
	\index{SRLV}
	\index{istruzioni!SRLV}
	\item \texttt{SRLV rd, rt, rs}\\
	Effettua uno shift verso destra del registro a 32-bit rt, del numero di bit specificato nei 5 bit bassi del registro rs che verr\`{a} letto come valore senza segno, 
	e pone il risultato nel registro a 32-bit rd. I bit liberi vengono posti a zero.

	\index{SUB}
	\index{istruzioni!SUB}
	\item \texttt{SUB rd, rs, rt}\\
	Sottrae il valore del registro a 32-bit rt al valore del registro a 32-bit rs, considerandoli come valori con segno,
	e pone il risultato in rd. Lancia un eccezione in caso di overflow.

	\index{SUBU}
	\index{istruzioni!SUBU}
	\item \texttt{SUBU rd, rs, rt}\\
	Sottrae il valore del registro a 32-bit rt al valore del registro a 32-bit rs, e pone il risultato in rd.
	Non si verificano eccezioni di overflow.
	\MISN{}

	\index{SLT}
	\index{istruzioni!SLT}
	\item \texttt{SLT rd, rs, rt}\\
	Pone il valore di rd ad 1 se il valore contenuto in rs \`{e} minore di quello contenuto in rt, 
	altrimenti pone rd a 0. Questa istruzione esegue un confronto con segno.

	\index{SLTU}
	\index{istruzioni!SLTU}
	\item \texttt{SLTU rd, rs, rt}\\
	Pone il valore di rd ad 1 se il valore contenuto in rs \`{e} minore di quello contenuto in rt, 
	altrimenti pone rd a 0. Questa istruzione esegue un confronto senza segno.

	\index{XOR}
	\index{istruzioni!XOR}
	\item \texttt{XOR rd, rs, rt}\\
	Esegue un OR esclusivo (XOR) bit a bit tra rs ed rt, e pone il risultato in rd.
\end{itemize}

Ecco la lista delle istruzioni ALU di tipo I.

\begin{itemize}
	\index{ADDI}
	\index{istruzioni!ADDI}
	\item \texttt{ADDI rt, rs, immediato}\\
	Effettua la somma tra il registro a 32 bit rs ed il valore immediato, ponendo il risultato in rt. 
	Questa istruzione considera gli operandi come valori con segno.
	Lancia un eccezione in caso di overflow.

	\index{ADDIU}
	\index{istruzioni!ADDIU}
	\item \texttt{ADDIU rt, rs, immediato}\\
	Effettua la somma tra il registro a 32 bit rs ed il valore immediato, ponendo il risultato in rt. 
	Non si verificano eccezioni di overflow.
	\MISN{}
	
	\index{ANDI}
	\index{istruzioni!ANDI}
	\item \texttt{ANDI rt, rs, immediato}\\
	Esegue un AND bit a bit tra rs ed il valore immediato, ponendo il risultato in rt.

	\index{DADDI}
	\index{istruzioni!DADDI}
	\item \texttt{DADDI rt, rs, immediato}\\
	Effettua la somma tra il registro a 64 bit rs ed il valore immediato, ponendo il risultato in rt. 
	Questa istruzione considera gli operandi come valori con segno.
	Lancia un eccezione in caso di overflow.

	\index{DADDIU}
	\index{istruzioni!DADDIU}
	\item \texttt{DADDIU rt, rs, immediato}\\
	Effettua la somma tra il registro a 64 bit rs ed il valore immediato, ponendo il risultato in rt. 
	Non si verificano eccezioni di overflow.
	\MISN{}

	\index{DADDUI}
	\index{istruzioni!DADDUI}
	\item \texttt{DADDUI rt, rs, immediato}\\
	Effettua la somma tra il registro a 64 bit rs ed il valore immediato, ponendo il risultato in rt. 
	Non si verificano eccezioni di overflow.
	\MISN{}
    \WARN{}

	\index{LUI}
	\index{istruzioni!LUI}
	\item \texttt{LUI rt, immediato}\\
	Carica la costante definita dal valore immediato nella met\`{a} superiore dei 32
	bit inferiori di rt, effettuando l'estensione del segno sui 32 bit superiori del registro. 

	\index{ORI}
	\index{istruzioni!ORI}
	\item \texttt{ORI rt, rs, immediato}\\
	Effettua l'OR bit a bit tra rs ed il valore immediato, ponendo il risultato in rt.

	\index{SLTI}
	\index{istruzioni!SLTI}
	\item \texttt{SLTI rt, rs, immediato}\\
	Pone il valore di rt ad 1 se il valore di rs \`{e} minore di quello dell'immediato, 
	altrimenti pone rt a 0. Questa operazione effettua un confronto con segno.

	\index{SLTUI}
	\index{istruzioni!SLTUI}
	\item \texttt{SLTUI rt, rs, immediato}\\
	Pone il valore di rt ad 1 se il valore di rs \`{e} minore di quello dell'immediato, 
	altrimenti pone rt a 0. Questa operazione effettua un confronto senza segno.
	
	\index{XORI}
	\index{istruzioni!XORI}
	\item \texttt{XORI rt, rs, immediato}\\
	Effettua l'OR esclusivo bit a bit tra rs ed il valore immediato, ponendo il risultato in rt.

\end{itemize}

\section{Istruzioni Load/Store}
Questa categoria contiene tutte le istruzioni che effettuano trasferimenti di dati tra i registri 
e la memoria. Ognuna di esse \`{e} espressa nella forma:

\begin{center}
	\texttt{[etichetta:] \textbf{ISTRUZIONE} rt, offset(base)}
\end{center}

In base all'utilizzo di un'istruzione load oppure store, rt rappresenter\`{a} di volta in volta il registro 
sorgente o destinazione; offset \`{e} un'etichetta o un valore immediato e base \`{e} un registro. 
L'indirizzo \`{e} ottenuto sommando al valore del registro\texttt{base} il valore immediato di \texttt{offset}.

L'indirizzo specificato deve essere allineato in base al tipo di dato che si sta trattando. 
Le istruzioni di caricamento che terminano con ``U'' considerano il contenuto del registro rt 
come un valore senza segno.

Ecco la lista delle istruzioni di caricamento (LOAD):

\begin{itemize}
	\index{LB}
	\index{istruzioni!LB}
	\item \texttt{LB rt, offset(base)}\\
	Carica il contenuto della cella di memoria all'indirizzo specificato da offset e base nel registro rt, 
	considerando tale valore come byte con segno.

	\index{LBU}
	\index{istruzioni!LBU}
	\item \texttt{LBU rt, offset(base)}\\
	Carica il contenuto della cella di memoria all'indirizzo specificato da offset e base nel registro rt, 
	considerando tale valore come byte senza segno.

	\index{LD}
	\index{istruzioni!LD}
	\item \texttt{LD rt, offset(base)}\\
	Carica il contenuto della cella di memoria all'indirizzo specificato da offset e base nel registro rt, 
	considerando tale valore come una double word.

	\index{LH}
	\index{istruzioni!LH}
	\item \texttt{LH rt, offset(base)}\\
	Carica il contenuto della cella di memoria all'indirizzo specificato da offset e base nel registro rt, 
	considerando tale valore come una half word con segno.

	\index{LHU}
	\index{istruzioni!LHU}
	\item \texttt{LHU rt, offset(base)}\\
	Carica il contenuto della cella di memoria all'indirizzo specificato da offset e base nel registro rt, 
	considerando tale valore come una half word senza segno.

	\index{LW}
	\index{istruzioni!LW}
	\item \texttt{LW rt, offset(base)}\\
	Carica il contenuto della cella di memoria all'indirizzo specificato da offset e base nel registro rt, 
	considerando tale valore come una word con segno.
	
	\index{LWU}
	\index{istruzioni!LWU}
	\item \texttt{LWU rt, offset(base)}\\
	Carica il contenuto della cella di memoria all'indirizzo specificato da offset e base nel registro rt, 
	considerando tale valore come una word senza segno.
\end{itemize}

Ecco la lista delle istruzioni di memorizzazione (STORE):

\begin{itemize}
	\index{SB}
	\index{istruzioni!SB}
	\item \texttt{SB rt, offset(base)}\\
	Memorizza il contenuto del registro rt nella cella di memoria specificata da offset e base, 
	considerando tale valore come un byte.
	
	\index{SD}
	\index{istruzioni!SD}
	\item \texttt{SD rt, offset(base)}\\
	Memorizza il contenuto del registro rt nella cella di memoria specificata da offset e base, 
	considerando tale valore come una double word.

	\index{SH}
	\index{istruzioni!SH}
	\item \texttt{SH rt, offset(base)}\\
	Memorizza il contenuto del registro rt nella cella di memoria specificata da offset e base, 
	considerando tale valore come una half word.

	\index{SW}
	\index{istruzioni!SW}
	\item \texttt{SW rt, offset(base)}\\
	Memorizza il contenuto del registro rt nella cella di memoria specificata da offset e base, 
	considerando tale valore come una word.
\end{itemize}

\section{Istruzioni di controllo del flusso}
Le istruzioni di controllo del flusso sono utilizzate per alterare l'ordine delle istruzioni prelevate 
dalla CPU nella fase di fetch. \`{E} possibile fare una distinzione tra tali istruzioni: tipo R, tipo I e tipo J.

\index{stalli!branch}
Tali istruzioni eseguono il salto alla fase di Instruction Decode (ID), ogni qual volta viene effettuato 
un fetch inutile. In tal caso, due istruzioni vengono rimosse dalla pipeline, ed il contatore degli stalli 
dovuti ai salti effettuati viene incrementato di due unit\'{a}.

Ecco la lista delle istruzioni di controllo del flusso di tipo R:
\begin{itemize}
	\index{JALR}
	\index{istruzioni!JALR}
	\item \texttt{JALR rs}\\
	Pone il contenuto di rs nel program counter, e salva in R31 l'indirizzo dell'istruzione che segue 
	l'istruzione JALR, che rappresenta il valore di ritorno.

	\index{JR}
	\index{istruzioni!JR}
	\item \texttt{JR rs}\\
	Pone il contenuto di rs nel program counter.
\end{itemize}

Ed ecco le istruzioni di controllo del flusso di tipo I:

\begin{itemize}
	\index{B}
	\index{instructions!B}
	\item \texttt{B offset}\\
	Salto incondizionato ad offset.

	\index{BEQ}
	\index{istruzioni!BEQ}
	\item \texttt{BEQ rs, rt, offset}\\
	Salta ad offset se rs \`{e} uguale ad rt.

	\index{BEQZ}
	\index{istruzioni!BEQZ}
	\item \texttt{BEQZ rs, offset}\\
	Salta ad offset se rs \`{e} uguale a zero.\\
	\WARN

	\index{BGEZ}
	\index{instructions!BGEZ}
	\item \texttt{BGEZ rs, offset}\\
	Effettua un salto relativo al PC ad offset se rs \`e maggiore di zero.

	\index{BNE}
	\index{istruzioni!BNE}
	\item \texttt{BNE rs, rt, offset}\\
	Salta ad offset se rs non \`{e} uguale ad rt.

	\index{BNEZ}
	\index{istruzioni!BNEZ}
	\item \texttt{BNEZ rs}\\
	Salta ad offset se rs non \`{e} uguale a zero.\\
	\WARN
\end{itemize}

Ecco la lista delle istruzioni di controllo del flusso di tipo J:

\begin{itemize}
	\index{J}
	\index{istruzioni!J}
	\item \texttt{J target}\\
	Pone il valore immediato nel program counter

	\index{JAL}
	\index{istruzioni!JAL}
	\item \texttt{JAL target}\\
	Pone il valore immediato nel program counter, e salva in R31 l'indirizzo 
	dell'istruzione che segue l'istruzione JAL, che rappresenta il valore di ritorno.
\end{itemize}

\section{L'istruzione \texttt{SYSCALL}}
\index{SYSCALL}
\label{sysc-man}
\index{istruzioni!SYSCALL}
\index{system calls}
L'istruzione \SC{} offre al programmatore un'interfaccia simile a quella offerta 
da un sistema operativo, rendendo disponibili sei differenti chiamate di sistema (system call).

Le system call richiedono che l'indirizzo dei loro parametri sia memorizzato nel registro R14, 
e pongono il loro valore di ritorno nel registro R1.
Tali system call sono il pi\`{u} possibile fedeli alla convenzione POSIX.

\index{system calls!exit()}
\subsection{\texttt{SYSCALL 0 - exit()}}
\SC{} 0 non richiede alcun parametro n\`{e} ritorna nulla, semplicemente ferma il simulatore.

\`{E} opportuno notare che se il simulatore non trova \SC{} 0 nel codice sorgente, 
o una qualsiasi istruzione equivalente (HALT  TRAP 0), terminer\`{a} automaticamente alla fine del sorgente.

\index{system calls!open()}
\subsection{\texttt{SYSCALL 1 - open()}}
\label{sys1}
\SC{} 1 richiede due parametri: una stringa (che termini con valore zero) che indica il percorso del file 
che deve essere aperto, ed una double word contenente un intero che indica i parametri che devono 
essere usati per specificare come aprire il file.

Tale intero pu\`{o} essere costruito sommando i parametri che si vogliono utilizzare, scelti dalla seguente lista:
\begin{itemize}
	\item \texttt{O\_RDONLY (0x01)} Apre il file in modalit\`{a} di sola lettura;
	\item \texttt{O\_WRONLY (0x02)} Apre il file in modalit\`{a} di sola scrittura;
	\item \texttt{O\_RDWR (0x03)} Apre il file in modalit\`{a} di lettura/scrittura;
	\item \texttt{O\_CREAT (0x04)} Crea il file se non esiste;
	\item \texttt{O\_APPEND (0x08)} In modalit\`{a} di scrittura, aggiunge il testo alla fine del file;
	\item \texttt{O\_TRUNC (0x08)} In modalit\`{a} di scrittura, cancella il contenuto del file al momento della sua apertura.
\end{itemize}

\`{E} obbligatorio specificare una delle prime tre modalit\`{a}. La quinta e la sesta sono esclusive, 
non \`{e} possibile specificare O\_APPEND se si specifica O\_TRUNC (e viceversa).Inoltre non si puo' specificare O\_CREAT 
se si specifica O\_RDONLY (oppure O\_RDWR).

\`{E} possibile specificare una combinazione di modalit\`{a} semplicemente sommando i valori interi ad esse associati. 
Ad esempio, se si vuole aprire un file in modalit\`{a} di sola scrittura ed aggiungere il testo alla fine del file, 
si dovr\`{a} specificare la modalit\`{a} $2 + 8 = 10$.

Il valore di ritorno delle chiamate di sistema \`{e} il nuovo descrittore del file (file descriptor) associato al file, 
che potr\`{a} essere utilizzato con le altre chiamate di sistema. Qualora si verifichi un errore, il valore di ritorno sar\`{a} -1.


\index{system calls!close()}
\subsection{\texttt{SYSCALL 2 - close()}}
\SC{} 2 richiede solo un parametro, il file descriptor del file che deve essere chiuso. 

 Qualora l'operazione termini con successo, \SC{} 2 ritorner\`{a} 0, altrimenti -1. 
 Possibili cause di errore sono il tentativo di chiudere un file inesistente, o di chiudere i file descriptor 0, 1 o 2, 
 che sono associati rispettivamente allo standard input, allo standard output ed allo standard error.

\index{system calls!read()}
\subsection{\texttt{SYSCALL 3 - read()}}
\SC{} 3 richiede tre parametri: il file descriptor da cui leggere, l'indirizzo nel quale i dati letti 
dovranno essere copiati, il numero di byte da leggere.

Se il primo parametro \`{e} 0, il simulatore permetter\`{a} all'utente di inserire un valore mediante un'apposita finestra di dialogo. 
Se la lunghezza del valore immesso \`{e} maggiore del numero di byte che devono essere letti, il simulatore mostrer\`{a} nuovamente la finestra.

La chiamata di sistema ritorna il numero di byte effettivamente letti, o -1 se l'operazione di lettura fallisce. Possibili cause di errore sono 
il tentativo di leggere da un file inesistente, o di leggere dai file descriptor 1 (standard output) o 2 (standard error), 
oppure il tentativo di leggere da un file di sola scrittura. 

\index{system calls!write()}
\subsection{\texttt{SYSCALL 4 - write()}}
\SC{} 4 richiede tre parametri: il file descriptor su cui scrivere, l'indirizzo dal quale i dati dovranno essere letti, il numero di byte da scrivere.

Se il primo parametro \`{e} 2 o 3, il simulatore mostrer\`{a} la finestra di input/output dove scriver\`{a} i dati letti.

Questa chiamata di sistema ritorna il numero di byte che sono stati scritti, o -1 se l'operazione di scrittura fallisce. 
Possibili cause di errore sono il tentativo di scrivere su un file inesistente, o sul file descriptor 0 (standard input), 
oppure il tentativo di scrivere su un file di sola lettura.

\index{system calls!printf()}
\label{sys5}
\subsection{\texttt{SYSCALL 5 - printf()}}
\SC{} 5 richiede un numero variabile di parametri, il primo \`{e} la cosiddetta
``format string'' o stringa di formato. Nella stringa di formato possono essere inseriti alcuni segnaposto,
descritti nella seguente lista:
\begin{itemize}
	\item \texttt{\%s} indica un parametro stringa;
	\item \texttt{\%i} indica un parametro intero;
	\item \texttt{\%d} si comporta come \texttt{\%i};
	\item \texttt{\%\%} indica \texttt{\%}
\end{itemize}

Per ciascuno dei segnaposto \texttt{\%s}, \texttt{\%d} o \texttt{\%i} la \SC{} 5
si aspetta un parametro, partendo dall'indirizzo del precedente.

Quando la \SC{} trova un segnaposto per un parametro intero, si aspetta che
il corrispondente parametro sia un valore intero, quando trova un segnaposto per un 
parametro stringa, si aspetta come parametro l'indirizzo della stringa stessa.

Il risultato  visualizzato nella finestra di input/output, ed il numero di byte scritti 
 posto in R1.

Qualora si verifichi un errore, R1 avr valore -1.

\section{Altre istruzioni}
In questa sezione sono descritte istruzioni che non rientrano nelle precedenti categorie.
\index{BREAK}
\index{istruzioni!BREAK}
\subsection{\texttt{BREAK}}
L'istruzione BREAK solleva un'eccezione che ha l'effetto di fermare l'esecuzione 
se il simulatore \`{e} in esecuzione. Pu\`{o} essere utilizzata per il debugging.

\index{NOP}
\index{istruzioni!NOP}
\subsection{\texttt{NOP}}
L'istruzione NOP non fa nulla, ed \`{e} utilizzata per creare pause nel codice sorgente.

\index{TRAP}
\index{istruzioni!TRAP}
\subsection{\texttt{TRAP}}
L'istruzione TRAP \`{e} deprecated, rappresenta un'alternativa all'istruzione \SC{}.

\index{HALT}
\index{istruzioni!HALT}
\subsection{\texttt{HALT}}
L'istruzione HALT \`{e} deprecated, rappresenta un'alternativa all'istruzione \SC{} 0, che ferma il simulatore.

\index{\EM{}!UI}
\index{\EM{}!GUI}
\chapter{L'interfaccia utente}
L'interfaccia grafica \EM{} \`{e} ispirata a quella di WinMIPS64. Infatti, la finestra principale \`{e} identica, 
eccetto che per qualche men\`{u}. 
% chapter~\ref{mips-simulators} for an overview of some MIPS and DLX simulators
% (including WinMIPS64), and to
%\cite{winmips-web} for more information about WinMIPS64.

%In figure~\ref{fig:edumips-main} you can see the main window of \EM{}, composed by
La finestra principale di \EM{} \`{e} caratterizzata da sei frame, che mostrano i differenti aspetti della simulazione. 
\`{E} inoltre presente una barra di stato, che ha il duplice scopo di mostrare il contenuto delle celle di memoria 
e dei registri quando vengono selezionati e di notificare all'utente che il simulatore \`{e} in esecuzione quando 
la simulazione \`{e} stata avviata ma la modalit\`{a} verbose  non \`{e} stata attivata. 
Maggiori dettagli sono descritti nelle sezioni a seguire.

\index{\EM{}!menu}
\section{La barra del men\`{u}}
La barra del men\`{u} contiene sei opzioni:

\index{\EM{}!menu!File}
\subsection{File}
Il men\`{u} File contiene comandi per l'apertura dei file, per resettare o fermare il simulatore e per scrivere i trace file.
\begin{itemize}
	\item \textbf{Apri...} Apre una finestra che consente all'utente di scegliere un file sorgente da aprire.
	\item \textbf{Apri recente} Mostra la lista dei file recentemente aperti dal simulatore, dalla quale l'utente pu\`{o} scegliere il file da aprire.
	\item \textbf{Resetta} Inizializza nuovamente il simulatore, mantenendo aperto il file che era stato caricato ma facendone ripartire l'esecuzione.
	\item \textbf{Scrivi Tracefile Dinero...} Scrive i dati di accesso alla memoria in un file, nel formato xdin.
	\item \textbf{Esci} Chiude il simulatore.
\end{itemize}
La voce del men\`{u} \textbf{Scrivi Tracefile Dinero...} \`{e} disponibile solo quando un file sorgente \`{e} 
stato completamente eseguito ed \`{e} stata gi\`{a} raggiunta la fine dell'esecuzione.


\index{\EM{}!menu!Esegui}
\subsection{Esegui}
Il menu Esegui contiene voci riguardanti il flusso di esecuzione della simulazione.
\begin{itemize}
	\item \textbf{Ciclo singolo} Esegue un singolo passo di simulazione.
	\item \textbf{Completa} Inizia l'esecuzione, fermandosi quando il simulatore raggiunge una \SC{} 0 (o equivalente) o
	un'istruzione di \texttt{BREAK}, oppure quando l'utente seleziona la voce Stop del men\`{u} (o preme F9).  
	\item \textbf{Cicli multipli} Esegue un certo numero di passi di
    simulazione, tale valore pu\`o essere configurato 
	attraverso la finestra di configurazione. Vedere la sezione~\ref{dialog-settings} per ulteriori dettagli.
	\item \textbf{Ferma} Ferma l'esecuzione quando il simulatore \`{e} in
    modalit\`{a} ``Completa'' o ``Cicli multipli'', come descritto precedentemente.
\end{itemize}
Il menu \`{e} disponibile solo quando \`{e} stato caricato un file sorgente e non \`{e} ancora stato raggiunto il termine della simulazione.
La voce \textbf{Stop} del men\`{u}  disponibile solo in modalit\`{a} ``Completa'' o ``Cicli multipli'' mode.

\index{\EM{}!menu!Configura}
\subsection{Configura}
Il menu Configura fornisce l'opportunit\`a di personalizzare l'aspetto ed il funzionamento di \EM{}.
\begin{itemize}
	\item \textbf{Impostazioni...} Apre la finestra di configurazione, descritta nella sezione~\ref{dialog-settings}
	\item \textbf{Selezione lingua} Consente di modificare la lingua usata dall'interfaccia utente. Attualmente sono 
	supportate solo inglese ed italiano. Questa modifica riguarda ogni aspetto dell'interfaccia grafica, 
	dal titolo delle finestre al manuale in linea ed i messaggi di errore o le notifiche.
\end{itemize}
The \texttt{Impostazioni...} non \`{e} disponibile quando il simulatore \`{e} in modalit\`{a} ``Completa'' o ``Cicli multipli'', a causa di possibili race conditions.

\index{\EM{}!menu!Strumenti}
\subsection{Strumenti}
Questo men\`{u} contiene solo una voce, utilizzata per aprire la finestra del Dinero frontend.
\begin{itemize}
	\item \textbf{Dinero Frontend...} Apre la finestra del Dinero Frontend. Vedi paragrafo~\ref{dialog-dinero}.
\end{itemize}
Questo men\`{u} non \`{e} disponibile finch\`{e} non \`{e} stata portata a termine l'esecuzione del programma

\index{\EM{}!menu!Finestra}
\subsection{Finestra}
Questo men\`{u} contiene voci relative alle operazioni con le finestre.
\begin{itemize}
	\item \textbf{Tile} Ordina le finestre visibili in modo tale che non vi siano pi\`{u} di tre finestre in una riga, 
	tentando di massimizzare lo spazio occupato da ciascuna finestra.
\end{itemize}
Le altre voci del men\`{u} modificano semplicemente lo stato di ciascuna finestra, rendendola visibile o riducendola ad icona.

\index{\EM{}!menu!Aiuto}
\subsection{Aiuto}
Questo men\`{u} contiene voci relative all'aiuto in linea.
\begin{itemize}
	\item \textbf{Manuale...} Mostra la finestra di help. Vedi~\ref{dialog-help}
	\item \textbf{Informazioni su...} Mostra una finestra contenente i nomi di coloro che hanno collaborato al progetto, 
	insieme ad i loro ruoli.
\end{itemize}

\index{\EM{}!Finestre}
\section{Finestre}
L'interfaccia grafica \`{e} composta da sette finestre, sei delle quali sono visibili per default, mentre una (la finestra di I/O) \`{e} nascosta.
\index{\EM{}!finestre!Cicli}
\subsection{Cicli}
La finestra Cicli mostra l'evoluzione del flusso di esecuzione nel tempo, visualizzando in ogni istante 
quali istruzioni sono nella pipeline, ed in quale stadio si trovano.
\index{\EM{}!finestre!Registri}
\subsection{Registri}
La finestra Registri mostra il contenuto di ciascun registro. Mediante un click col tasto sinistro del mouse 
\`{e} possibile vedere il loro valore decimale (con segno) nella barra di stato, mentre con un doppio click verr\`{a} 
aperta una finestra di dialogo che consentir\`{a} all'utente di cambiare il valore del registro

\index{\EM{}!finestre!Statistiche}
\subsection{Statistiche}
La finestra Statistiche mostra alcune statistiche riguardanti l'esecuzione del programma.

\index{\EM{}!finestre!Pipeline}
\subsection{Pipeline}
La finestra Pipeline mostra lo stato attuale della pipeline, visualizzando ciascuna istruzione con il suo stadio. 
I differenti colori evidenziano i vari stadi della pipeline stessa.

\index{\EM{}!finestre!Memoria}
\subsection{Memoria}
La finestra Memoria mostra il contenuto delle celle di memoria, insieme alle etichette ed i commenti, 
tratti dal codice sorgente. Il contenuto delle celle di memoria, come per i registri, pu\`{o} essere modificato 
con un doppio click, e mediante un singolo click del mouse verr\`{a} mostrato il loro valore decimale nella barra di stato. 
La prima colonna mostra l'indirizzo esadecimale della cella di memoria, e la seconda il valore della cella stessa. 
Le altre colonne mostrano invece informazioni addizionali provenienti dal codice sorgente.

\index{\EM{}!finestre!Codice}
\subsection{Codice}
La finestra Codice visualizza le istruzioni caricate in memoria.. La prima colonna mostra l'indirizzo dell'istruzione, 
mentre la seconda mostra la rappresentazione esadecimale dell'istruzione stessa. Le altre colonne mostrano infine 
informazioni addizionali provenienti dal codice sorgente.

\index{\EM{}!finestre!Input/Output}
\subsection{Input/Output}
La finestra Input/Output fornisce un'interfaccia all'utente per la visualizzazione dell'output creato dai programmi 
mediante le \SC{} 4 e 5. Attualmente non \`{e} utilizzata per l'input di dati, ed al suo posto viene utilizzata una 
finestra di dialogo che viene mostrata quando una \SC{} 3  tenta di leggere dallo standard input, 
ma future versioni includeranno una casella di testo per l'input.

\index{\EM{}!finestre di dialogo}
\section{Finestre di dialogo}
Le finestre di dialogo sono utilizzate da EduMIPS64 per interagire con l'utente
in vari modi. Ecco un riassunto delle pi\`u importanti:

\index{\EM{}!finestre di dialogo!Impostazioni}
\subsection{Impostazioni}
\label{dialog-settings}
Nella finestra di configurazione possono essere configurati vari aspetti del simulatore.

La sezione ``Impostazioni generali'' consente di configurare il forwarding ed il numero di passi da effettuare nella modalit\`{a} Cicli multipli.

La sezione ``Comportamento'' permette di abilitare o disabilitare gli avvisi durante la fase di parsing, 
l'opzione ``sincronizza la GUI con la CPU nell'esecuzione multi step'', quando abilitata, sincronizzer\`{a}
lo stato grafico delle finestre con lo stato interno del simulatore. Ci\`{o} implicher\`{a} una simulazione pi\`{u} lenta, 
ma con la possibilit\`{a} di avere un resoconto grafico esplicito di ci\`{o} che sta avvenendo durante la simulazione. 
L'opzione ``intervallo tra i cicli'', qualora sia abilitata, influenzer\`{a} il numero di millisecondi che il simulatore dovr\`{a} 
attendere prima di cominciare un nuovo ciclo. Tali opzioni hanno effetto solo quando la simulazione \`{e} avviata 
utilizzando le opzioni ``Completa'' o ``Cicli multipli'' dal menu Esegui.

Le ultime due opzioni stabiliscono il comportamento del simulatore quando si verifica un'eccezione sincrona. 
\`{E} importante notare che se le eccezioni sincrone sono mascherate, non succeder\`{a} nulla, anche se l'opzione 
``Termina se si verifica un'eccezione sincrona'' \`{e} abilitata. Se le eccezioni non sono mascherate e tale opzione \`{e} abilitata, apparir\`{a} una finestra di dialogo, 
e la simulazione sar\`{a} fermata non appena tale finestra verr\`{a} chiusa.

L'ultima sezione permette di modificare i colori associati ai diversi stadi della pipeline. Abbastanza inutile, ma carino.

\index{\EM{}!finestre di dialogo!Dinero Frontend}
\subsection{Dinero Frontend}
\label{dialog-dinero}
La finestra di dialogo Dinero Frontend consente di avviare un processo DineroIV con il trace file 
generato internamente mediante l'esecuzione del programma. Nella prima casella di testo c'\`{e} il percorso 
dell'eseguibile DineroIV, e nella seconda devono essere inseriti i parametri opportuni.

% Please see~\cite{dinero-web} for further informations about the DineroIV cache simulator.

La sezione pi\`{u} in basso contiene l'output del processo DineroIV, dal quale \`{e} possibile prelevare i dati di cui si necessita.

\index{\EM{}!finestre di dialogo!Aiuto}
\subsection{Aiuto}
\label{dialog-help}
La finestra di Aiuto contiene tre sezioni con qualche indicazione riguardo l'utilizzo del simulatore. 
La prima \`{e} una breve introduzione ad EduMIPS64, la seconda contiene informazioni riguardanti 
l'interfaccia grafica e la terza contiene un riassunto delle istruzioni supportate.

\index{\EM{}!Opzioni da linea di comando}
\section{Opzioni da linea di comando}
Sono disponibili tre opzioni da linea di comando. Esse sono descritte di seguito, con il nome per esteso scritto tra parentesi. 
Nomi abbreviati e per esteso possono essere utilizzati indifferentemente.
\begin{itemize}
	\item \texttt{-h (--help)} mostra un messaggio di aiuto contenente la versione del simulatore ed un breve riassunto delle opzioni da linea di comando.
	\item \texttt{-f (--file) filename} Apre \texttt{filename} nel simulatore.
	\item \texttt{-d (--debug)} Accede alla modalit\`{a} di debugging.
\end{itemize}

L'opzione \texttt{--debug} ha l'effetto di attivare la modalit\`{a} di debugging. 
In tale modalit\`a \`{e} disponibile una nuova finestra, la finestra Debug, che mostra il resoconto delle 
attivit\`{a} interne di  \EM{}. Tale finestra non \`{e} utile per l'utente finale, \`{e} stata infatti ideata per poter essere utilizzata 
dagli sviluppatori di \EM{}.

\index{\EM{}!esecuzione}
\section{Eseguire \EM{}}
Il file \texttt{.jar} di \EM{} pu\`{o} funzionare sia come file .jar eseguibile che come applet, 
quindi pu\`{o} essere eseguito in entrambi i modi, che richiedono il Java Runtime Environment, versione 5 o successiva.

Per eseguire il file come applicazione a s\`{e} stante, l'eseguibile \texttt{java} deve essere avviato nel seguente modo: 
\texttt{java -jar edumips64-version.jar}, dove la stringa
\texttt{version} deve essere sostituita con la versione attuale del simulatore. 
Su alcuni sistemi, potrebbe essere possibile eseguire il programma semplicemente con un click sul file \texttt{.jar}.

Per eseguire il file come applet deve essere utilizzato il tag \texttt{<applet>}. Il sito web di \EM{}
presenta una pagina gi\`{a} contenente l'applet, in modo tale che chiunque possa eseguire il programma senza il problema dell'utilizzo da linea di comando.

%\cite{edumips-web} contains a page that already contains the applet, so
%that everyone can execute it without the hassle of using the command line.
\printindex

\chapter{Listati di esempio}
Qui di seguito sono elencati degli esempi utili per comprendere il funzionamento delle istruzioni che accetta \EM{} (versione \EV)
\section{\SC{}}
Per informazioni dettagliate riguardo l'utilizzo delle \SC{} consultare la sezione \ref{sysc-man}. Di seguito si trovano degli esempi pratici per ognuna delle 6 \SC{}:
\subsection{\SC{} 0}
La \SC{} 0, quando invocata, termina l'esecuzione del programma.
Eccone un esempio:
\begin{lstlisting}[caption={syscall0}, label={code:syscall0}, style={mips}]
        .code
        daddi   r1, r0, 0	;salva 0 nel registro R1
        syscall 0	    	;esce dal programma
\end{lstlisting}

\subsection{\SC{} 1}
Ecco un esempio di programmma che apre un file:
\begin{lstlisting} [caption={syscall1}, label={code:syscall1}, style={mips} ] 
      	.data
error_op:	.asciiz	"An error occurred opening file"	

ok_message:	.asciiz	"All right, operation succesfully done"

params_sys1:	.asciiz	"filename.txt"
						.word64	0xF					

	.text
	#include print.s			
open:
	daddi r14,r0,params_sys1	
	syscall 1	
	daddi $s0,r0,-1
	dadd $s2,r0,r1		
	daddi $a0,r0,ok_message	
	BNE r1 $s0,print_string	
	daddi $a0,r0,error_op		
	jal print_string			
\end{lstlisting}
Inizialmente vengono salvati in memoria i dati richiesti dalla \SC{} 1 (righe 2, 3), cioe'
la stringa contenente il path del file da aprire(che deve esistere), e (nella locazione di
memoria immediatamente successiva) un intero che ne definisce la modalita' di
apertura(per maggiori informazioni sulla modalita' di aprtura di un file rimandiamo alla sezione \ref{sys1}).
Si applica un' etichetta a questi dati per potervici accedere
in seguito.Successivamente (righe 5, 7) si salvano in memoria (e gli si assegna un'etichetta)
le stringe relative ai messaggi di successo ed errore da passare alla funzione
'print\_string' (presente nel file print.s).Passando alla sezione .text, inizialmente si salva
l'indirizzo di params\_sys1 (che per il compilatore \'{e} un numero) nel registro
r14; subito dopo si pu\'{o} chiamare la \SC{} 1 e salvare il registro r1(che contiene il valore di ritorno) in \$s2
(in modo da poterlo riutilizzare, per esempio, con le altre
\SC{}).A questo punto viene chiamata la funzione 'print\_string' facendo in modo
da passargli l'indirizzo di 'error\_op' nel caso in cui r1 sia uguale a $-1$(righe
18-19).  Altrimenti si chiama la stessa funzione facendo in modo di
passargli l'indirizzo di 'ok\_message' (righe 16-17).

\subsection{\SC{} 2}
Ecco un esempio di un programma che chiude un file:
\begin{lstlisting}[caption={syscall2}, label={code:syscall2}, style={mips}]
      		.data
params_sys2:	.space 8

error_cl:	.asciiz "An error occurred closing file"

ok_message:	.asciiz "All right, operation succesfully done"						


	.text
	#include print.s	
close:	
	daddi r14,r0,params_sys2		
	sw $s2,params_sys2(r0)	
	syscall 2			
	daddi $s0,r0,-1		
	daddi $a0,r0,ok_message		
	BNE r1,$s0,print_string		
	daddi $a0,r0,error_cl	
	jal print_string			
\end{lstlisting}
Inizialmente viene salvato in memoria l'unico dato richiesto dalla \SC{} 2, cioe'  il file descriptor del file da chiudere(riga 2) e gli si applica un' etichetta
 per potervici accedere in seguito.Successivamente si salvano in memoria (e gli si assegna un'etichetta) le stringe relative ai messaggi 
di successo ed errore da passare alla funzione 'print\_string'(righe 4, 6).Passando alla sezione .text, inizialmente si salva l'indirizzo di params\_sys2
(che per il compilatore \'{e} un numero) nel registro r14; subito dopo si pu\'{o} chiamare la \SC{} 2.
A questo punto viene chiamata la funzione print\_string (presente nel file print.s) facendo in modo da passargli l'indirizzo di 'error\_cl' nel caso in cui r1 sia uguale a $-1$(righe 18, 19).
Altrimenti si chiama la stessa funzione facendo in modo di passargli l'indirizzo di 'ok\_message' (righe 16, 17).
\OF{}

\subsection{\SC{} 3}
Ecco un esempio di un programma che legge 30 byte da un file e li salva in memoria:
\begin{lstlisting}[caption={syscall3}, label={code:syscall3}, style={mips}]
      		.data
params_sys3:	.space 8				
ind_value:	.space 8			
	.word64 16		

error_3:	.asciiz "An error occurred reading file"	

ok_message:	.asciiz "All right, operation succesfully done"	

value:	.space 30					

			


	.text
#include print.s	

read:
	daddi r14,r0,params_sys3	
	sw $s2,params_sys3(r0)
	daddi $s1,r0,value			
	sw $s1,ind_value(r0)			
	syscall 3			
	daddi $s0,r0,-1			
	BNE r1,$s0,print_string	
	daddi $a0,r0,error_3
	jal print_string
\end{lstlisting}

Inizialmente vengono salvati in memoria i dati richiesti dalla \SC{} 3, cioe' il file descriptor del file da cui leggere (riga 2), 
l'indirizzo di memoria in cui inserire i byte letti(riga 3), e il numero di byte da leggere(riga 4).Si applica un' etichetta
 a questi dati per potervici accedere in seguito.Successivamente si salvano in memoria (e gli si assegna un'etichetta) le stringe relative ai messaggi 
di successo ed errore da passare alla funzione 'print\_string'(righe 6, 8).Passando alla sezione .text, inizialmente si salva l'indirizzo di params\_sys3
(che per il compilatore \'{e} un numero) nel registro r14;dopodich\'{e} salviamo nelle apposite locazioni 
di memoria l'indirizzo del file descriptor (che supponiamo avere nel registro \$s2) e l'indirizzo su cui andare a salvare i byte letti(ossia l'indirizzo di 'value').
Subito dopo si pu\'{o} chiamare la \SC{} 3.A questo  punto viene chiamata la funzione print\_string (presente nel file print.s) facendo in modo da passargli l'indirizzo di 'error\_3'
 nel caso in cui r1 sia uguale a $-1$(righe 26, 27). Altrimenti si chiama la funzione 'print\_string' facendo in modo di passargli l'indirizzo di \_'ok\_message' (righe 24, 25).
\OF{}
\subsection{\SC{} 4}
Ecco un esempio di un programma che scrive su un file una stringa salvata in memoria:
\begin{lstlisting}[caption={syscall4}, label={code:syscall4}, style={mips}]
      		.data
params_sys4:	.space 8			
ind_value:	.space 8			
	.word64 16		

error_4:	.asciiz "An error occurred writing file"	

ok_message:	.asciiz "All right, operation succesfully done"	

value:	.space 30								


	.text
#include print.s	

read:
	daddi r14,r0,params_sys4
	sw $s2,params_sys3_4(r0)
	daddi $s1,r0,value	
	sw $s1,ind_value(r0)	
	syscall 3			
	daddi $s0,r0,-1			
	BNE r1,$s0,print_string
	daddi $a0,r0,error_4
	jal print_string				
\end{lstlisting}

Inizialmente vengono salvati in memoria i dati richiesti dalla \SC{} 4, cioe'
il file descriptor del file su cui scrivere (riga 2), l'indirizzo di memoria da
cui prelevare i byte da scrivere(riga 3), e il numero di byte da scrivere(riga
4).Si applica un' etichetta a questi dati per potervici accedere in
seguito.Successivamente si salvano in memoria (e gli si assegna un'etichetta) le
stringe relative ai messaggi di successo ed errore da passare alla funzione
'print\_string'(righe 6, 8).Passando alla sezione .text, inizialmente si salva
l'indirizzo di params\_sys4 (che per il compilatore \'{e} un numero) nel
registro r14;dopodich\'{e} salviamo nelle apposite locazioni di memoria l'indirizzo 
del file descriptor (che supponiamo avere nel registro \$s2) e l'indirizzo da cui leggere 
i byte da scrivere(ossia l'indirizzo di 'value'). Subito dopo si pu\'{o} chiamare la
\SC{} 4.A questo  punto viene chiamata la funzione print\_string (presente nel file print.s) 
facendo in modo da passargli l'indirizzo di 'error\_4' nel caso in cui r1 sia uguale a
$-1$(righe 24, 25). Altrimenti si chiama la funzione 'print\_string' facendo in
modo di passargli l'indirizzo di 'ok\_message' (righe 22, 23).
\OF{}
\subsection{\SC{} 5}
Ecco un esempio di un programma che contiene una funzione che stampa nello standard output
la stringa contenuta nel registro \$a0:
\begin{lstlisting}[caption={syscall5}, label={code:syscall5}, style={mips}]
    .data
params_sys5: .space 8	  			
	.text
print_string:
	sw \$a0,params_sys5(r0)	
	daddi r14,r0,params_sys5
	syscall 5
	syscall 0				
\end{lstlisting}
Inizialmente vengono salvati in memoria i dati richiesti dalla \SC{} 5, cioe'
la stringa da stampare(riga 2) e gli si applica un' etichetta per potervici
accedere in seguito.Nel caso la stringa necessiti di inserire altri parametri in
memoria(vedi \ref{sys5}), questi dovranno necessariamente essere inseriti
nell'area di memoria immediatamente sucessiva a 'params\_sys5', (cio nelle
righe 3, 4, etc..).  Passando alla sezione .text, inizialmente si salva
l'indirizzo di params\_sys5 (che per il compilatore \'{e} un numero) nel
registro r14; subito dopo si pu\'{o} chiamare la \SC{} 5 che stampa nello 
standard output (una finestra didialogo) la stringa desiderata.

\end{document}
