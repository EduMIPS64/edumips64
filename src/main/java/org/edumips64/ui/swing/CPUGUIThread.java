/* CPUGUIThread.java
 *
 * This class handles the multi-threaded CPU object, and acts as a proxy between
 * the Main class and the CPU class.
 * (c) 2006 Antonella Scandura, Andrea Spadaccini
 *
 * This file is part of the EduMIPS64 project, and is released under the GNU
 * General Public License.
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 2 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
 */

package org.edumips64.ui.swing;

import org.edumips64.*;
import org.edumips64.core.*;
import org.edumips64.core.is.*;
import org.edumips64.utils.*;

import java.util.logging.Logger;
import javax.swing.*;

/** This class handles the multi-threaded CPU object, and acts as a proxy between
 * the Main class and the CPU class.
 * @author Antonella Scandura
 * @author Andrea Spadaccini
 * */
public class CPUGUIThread extends Thread {

  /** Needed for multithreading. */
  private int nStep;

  /** Booleans for synchronous exception handling */
  private boolean masked;
  private boolean terminate;

  /** Boolean describing if the CPU is running */
  private boolean externalStop;

  /** Verbose mode */
  private boolean verbose;

  /** Sleep interval between cycles in verbose mode */
  private int sleep_interval;

  private CPU cpu;
  private GUIFrontend front;
  private JFrame f;
  private ConfigStore config;

  private static final Logger logger = Logger.getLogger(CPUGUIThread.class.getName());

  public CPUGUIThread(CPU cpu, GUIFrontend front, JFrame mainFrame, ConfigStore config) {
    externalStop = false;
    this.cpu = cpu;
    this.front = front;
    f = mainFrame;
    this.config = config;
    updateConfigValues();
  }

  /** Used to refresh the internal configuration values. Takes the needed
   * configuration values from the configuration file.
   */
  public void updateConfigValues() {
    sleep_interval = config.getInt(ConfigKey.SLEEP_INTERVAL);
    verbose = config.getBoolean(ConfigKey.VERBOSE);
    masked = config.getBoolean(ConfigKey.SYNC_EXCEPTIONS_MASKED);
    terminate = config.getBoolean(ConfigKey.SYNC_EXCEPTIONS_TERMINATE);
    logger.info("Terminate = " + terminate + "; masked = " + masked);
  }

  /** Allows external classes to stop the execution. */

  public synchronized void stopExecution() {
    externalStop = true;
  }

  /** Sets the number of cpu cycles. Set a negative number if you want the CPU
   * to cycle endlessly.
   * @param n an integer value*/

  public synchronized void setSteps(int n) {
    nStep = n;
  }

  private synchronized void haltCPU() {
    logger.info("Halting the CPU.");
    front.updateComponents();
    cpu.setStatus(CPU.CPUStatus.HALTED);
    Main.changeShownMenuItems(CPU.CPUStatus.HALTED);
  }

  /** Run method: waits for an external thread that sends the notify. When the
   * notify arrives, the method will execute nStep CPU cycles if nStep is
   * positive or equal to zero, or it will cycle indefinitely if nStep is
   * negative.
   */
  public void run() {
    try {
      while (true) {
        synchronized (this) {
          logger.info("cgt is waiting");
          wait();
        }

        logger.info("cgt awoke");

        // Let's disable the running menu items and enable the stop menu
        // item
        Main.setRunningMenuItemsStatus(false);
        Main.setStopStatus(true);

        // Progress bar
        Main.startPB();

        // If the nStep variable is set to a value < 0, then we must loop forever (an exception
        // will be the way to terminate execution); otherwise, we must be looping only
        // 'nStep' number of times.

        int steps = 0;

        while (true) {
          if (steps++ == nStep) {
            break;
          }

          if (verbose && (sleep_interval != 0)) {
            sleep(sleep_interval);
          }

          synchronized (this) {
            if (externalStop) {
              externalStop = false;
              logger.info("Stopping cycles because of external interaction.");
              break;
            }
          }

          // TODO: CPUGUIThread should probably only deal with the multithreading work needed for the background
          // execution of code and also deal with updating the GUI. It should not handle exceptions generated by
          // step(), that should probably instead be handled by the CPU itself.
          try {
            cpu.step();
            front.updateComponents();

            if (verbose) {
              front.represent();
            }
          } catch (StoppedCPUException ex) {
            logger.info("CPUGUIThread: CPU was stopped");
            front.updateComponents();

            if (verbose) {
              front.represent();
            }

            break;
          } catch (BreakException ex) {
            front.updateComponents();

            if (verbose) {
              front.represent();
            }

            break;
          } catch (SynchronousException ex) {
            logger.info("Caught a synchronous exception.");
            JOptionPane.showMessageDialog(f, CurrentLocale.getString(ex.getCode() + ".Message"), "EduMIPS64 - " + CurrentLocale.getString("EXCEPTION"), JOptionPane.ERROR_MESSAGE);
            front.updateComponents();
            front.represent();

            if (terminate) {
              haltCPU();
              break;
            }
          } catch (HaltException ex) {
            haltCPU();
            logger.info("CPUGUIThread: CPU Halted because of HaltException.");
            front.updateComponents();

            if (verbose) {
              front.represent();
            }
            break;
          } catch (NotAlignException ex) {
            logger.info("NotAlignException.");
            haltCPU();
            logger.info(ex.getMessage());
            JOptionPane.showMessageDialog(org.edumips64.Main.ioFrame, ex.getMessage(), "EduMIPS64 - " + CurrentLocale.getString("ERROR"), JOptionPane.ERROR_MESSAGE);
          } catch (AddressErrorException ex) {
            logger.info("AddressErrorException.");
            haltCPU();
            logger.info(ex.getMessage());
            JOptionPane.showMessageDialog(org.edumips64.Main.ioFrame, ex.getMessage(), "EduMIPS64 - " + CurrentLocale.getString("ERROR"), JOptionPane.ERROR_MESSAGE);
          } catch (MemoryElementNotFoundException ex) {
            logger.info("Attempt to read a non-existent cell (MemoryElementNotFoundException).");
            haltCPU();
            JOptionPane.showMessageDialog(org.edumips64.Main.ioFrame, CurrentLocale.getString("ERROR_LABEL"), "EduMIPS64 - " + CurrentLocale.getString("ERROR"), JOptionPane.ERROR_MESSAGE);
            break;
          } catch (Exception ex) {
            logger.info("Exception in CPUGUIThread");
            logger.warning(ex.toString());
            haltCPU();
            new ReportDialog(f, ex, CurrentLocale.getString("GUI_STEP_ERROR"));
            break;
          }
        }

        // Represent changes, in case the user chose non-verbose mode.
        front.represent();

        if (cpu.getStatus() != CPU.CPUStatus.HALTED) {
          Main.setRunningMenuItemsStatus(true);
        }

        Main.setStopStatus(false);
        Main.stopPB();
      }
    } catch (InterruptedException e) {
      e.printStackTrace();
    }
  }
}
