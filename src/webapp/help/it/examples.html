

<html lang="it" data-content_root="./">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" /><meta name="viewport" content="width=device-width, initial-scale=1" />

    <title>Listati di esempio &#8212; Documentazione EduMIPS64 1.3.0 </title>
    <link rel="stylesheet" type="text/css" href="_static/pygments.css?v=03e43079" />
    <link rel="stylesheet" type="text/css" href="_static/epub.css?v=e4d0adb4" />
    <script src="_static/documentation_options.js?v=79d73783"></script>
    <script src="_static/doctools.js?v=9bcbadda"></script>
    <script src="_static/sphinx_highlight.js?v=dc90522c"></script>
    <script src="_static/translations.js?v=45930005"></script> 
  </head><body>

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            
  <section id="listati-di-esempio">
<h1>Listati di esempio<a class="headerlink" href="#listati-di-esempio" title="Link to this heading">¶</a></h1>
<p>In questo capitolo sono presenti degli esemi di codice utili per comprendere
il funzionamento del simulatore.</p>
<section id="syscall">
<h2>SYSCALL<a class="headerlink" href="#syscall" title="Link to this heading">¶</a></h2>
<p>Gli esempi per le SYSCALL 1-4 si riferiscono al file <cite>print.s</cite>, che è
l’esempio per la SYSCALL 5. Se si desidera eseguire gli esempi, è prima
necessario copiare il contenuto di quell’esempio in un file denominato
<cite>print.s</cite>, e salvarlo nella stessa directory contenente l’esempio che si sta
eseguendo.</p>
<p>Alcuni esempi si aspettano che esista un file descriptor, e non contengono il
codice per aprire alcun file. Per eseguire questi esempi, eseguire prima la
SYSCALL 1.</p>
<section id="syscall-0">
<h3>SYSCALL 0<a class="headerlink" href="#syscall-0" title="Link to this heading">¶</a></h3>
<p>L’effetto dell’esecuzione della SYSCALL 0 è l’interruzione dell’esecuzione
del programma. Esempio:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="o">.</span><span class="n">code</span>
<span class="n">daddi</span>   <span class="n">r1</span><span class="p">,</span> <span class="n">r0</span><span class="p">,</span> <span class="mi">0</span>    <span class="p">;</span> <span class="n">salva</span> <span class="n">il</span> <span class="n">valore</span> <span class="mi">0</span> <span class="ow">in</span> <span class="n">R1</span>
<span class="n">syscall</span> <span class="mi">0</span>            <span class="p">;</span> <span class="n">termina</span> <span class="n">l</span><span class="s1">&#39;esecuzione</span>
</pre></div>
</div>
</section>
<section id="syscall-1">
<h3>SYSCALL 1<a class="headerlink" href="#syscall-1" title="Link to this heading">¶</a></h3>
<p>Programma d’esempio che apre un file:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>                .data
error_op:       .asciiz     &quot;Errore durante l&#39;apertura del file&quot;
ok_message:     .asciiz     &quot;Tutto ok.&quot;
params_sys1:    .asciiz     &quot;filename.txt&quot;
                .word64     0xF

                .text
open:           daddi       r14, r0, params_sys1
                syscall     1
                daddi       $s0, r0, -1
                dadd        $s2, r0, r1
                daddi       $a0,r0,ok_message
                bne         r1,$s0,end
                daddi       $a0,r0,error_op

end:            jal         print_string
                syscall 0

                #include    print.s
</pre></div>
</div>
<p>Nelle prime due righe, vengono salvate in memoria le stringhe che contengono
i messaggi di errore e di successo, che saranno poi passati come parametri
alla funzione <cite>print_string</cite>, ed a ciascuno di essi viene associata
un’etichetta. La funzione <cite>print_string</cite> è presente nel file <cite>print.s</cite>.</p>
<p>Successivamente, vengono salvati in memoria i dati richiesti dalla SYSCALL 1,
il percorso del file da aprire (che deve esistere se si apre il file in
modalità sola lettura o lettura/scrittura) e, nella cella successiva, un
intero che definisce la modalità di apertura.</p>
<p>In questo esempio, il file è stato aerto utilizzando la seguente modalità:
<cite>O_RDWR</cite> | <cite>O_CREAT</cite> | <cite>O_APPEND</cite>. Il numero 15 (0xF in base 16) deriva dalla
somma dei valori di queste tre modalità modes (3 + 4 + 8).</p>
<p>Questi due parametri hanno un’etichetta, in modo che in seguito possano essere
utilizzati.</p>
<p>Nella sezione .text, come prima cosa l’indirizzo di <cite>param_sys1</cite> - che per il
compilatore è un numero - viene salvato in r14; successivamente viene chiamata
la SYSCALL 1, ed il contenuto di R1 viene salvato nel registro $s2, in modo
che possa essere utilizzato nel resto del programma (ad esempio, con un’altra
SYSCALL).</p>
<p>Infine viene chiamata la funzione <cite>print_string</cite>, passando come parametro
<cite>error_op</cite> se R1 contiene il valore -1 (righe 13-14), altrimenti utlizzando
<cite>ok_message</cite> (righe 12-16).</p>
</section>
<section id="syscall-2">
<h3>SYSCALL 2<a class="headerlink" href="#syscall-2" title="Link to this heading">¶</a></h3>
<p>Programma di esempio che chiude un file:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>                .data
params_sys2:    .space 8
error_cl:       .asciiz     &quot;Errore durante la chiususra del file&quot;
ok_message:     .asciiz     &quot;Tutto a posto&quot;

                .text
close:          daddi       r14, r0, params_sys2
                sw          $s2, params_sys2(r0)
                syscall     2
                daddi       $s0, r0, -1
                daddi       $a0, r0, ok_message
                bne         r1, $s0, end
                daddi       $a0, r0, error_cl

end:            jal         print_string
                syscall     0

                #include    print.s
</pre></div>
</div>
<p><strong>Nota:</strong> Questo esempio richiede che in $s2 ci sia il file descriptor del
file da chiudere.</p>
<p>Come prima cosa viene allocata della memoria per l’unico parametro di SYSCALL
2, il file descriptor del file da chiudere, e a questo spazio viene associata
un’etichetta in modo da potervicisi riferire successivamente.</p>
<p>Successivamente vengono salvate in memoria le stringhe contenenti i messaggi
di successo e di errore.</p>
<p>Nella sezione .text, l’indirizzo di <cite>param_sys2</cite> viene salvato in R14;
successivamente viene chiamata la SYSCALL 2.</p>
<p>Infine viene chiamata la funzione <cite>print_string</cite>, stampando il messaggio
d’errore se ci sono problemi (riga 13) o, se tutto è andato a buon fine, il
messaggio di successo (riga 11).</p>
</section>
<section id="syscall-3">
<h3>SYSCALL 3<a class="headerlink" href="#syscall-3" title="Link to this heading">¶</a></h3>
<p>Programma di esempio che legge 16 byte da un file e li salva in memoria:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>                .data
params_sys3:    .space      8
ind_value:      .space      8
                .word64     16
error_3:        .asciiz     &quot;Errore durante la lettura da file.&quot;
ok_message:     .asciiz     &quot;Tutto ok.&quot;

value:          .space      30

                .text
read:           daddi       r14, r0, params_sys3
                sw          $s2, params_sys3(r0)
                daddi       $s1, r0, value
                sw          $s1, ind_value(r0)
                syscall     3
                daddi       $s0, r0, -1
                daddi       $a0, r0,ok_message
                bne         r1, $s0,end
                daddi       $a0, r0,error_3

end:            jal         print_string
                syscall     0

                #include    print.s
</pre></div>
</div>
<p>Le prime 4 righe della sezione .data contengono i parametri della SYSCALL 3,
il file descriptor da cui si devono leggere i dati, l’indirizzo della cella di
memoria dove la SYSCALL deve salvare i dati letti, il numero di byte da
leggere. Successivamente sono presenti in memoria i messaggi di successo e di
errore.</p>
<p>Nella sezione .text, come prima cosa viene salvato l’indirizzo di <cite>param_sys3</cite>
in r14, il file descriptor viene salvato nell’area di memoria dedicata ai
parametri della SYSCALL, ed a seguire lo stesso destino tocca all’indirizzo
dell’area di memoria adibita a contenere i dati letti.</p>
<p>Successivamente viene chiamata la SYSCALL 3 e viene stampato un messaggio di
successo o di errore, a seconda dell’esito della SYSCALL.</p>
</section>
<section id="syscall-4">
<h3>SYSCALL 4<a class="headerlink" href="#syscall-4" title="Link to this heading">¶</a></h3>
<p>Programma di esempio che scrive su file una stringa:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>                .data
params_sys4:    .space      8
ind_value:      .space      8
                .word64     16
error_4:        .asciiz     &quot;Errore durante la scrittura su stringa.&quot;
ok_message:     .asciiz     &quot;Tutto ok.&quot;
value:          .space      30

                .text

write:          daddi       r14, r0,params_sys4
                sw          $s2, params_sys4(r0)
                daddi       $s1, r0,value
                sw          $s1, ind_value(r0)
                syscall     4
                daddi       $s0, r0,-1
                daddi       $a0, r0,ok_message
                bne         r1, $s0,end
                daddi       $a0, r0,error_4

end:            jal         print_string
                syscall     0

                #include    print.s
</pre></div>
</div>
<p>La struttura di quest’esempio è identica a quella dell’esempio di SYSCALL 3.</p>
</section>
<section id="syscall-5">
<h3>SYSCALL 5<a class="headerlink" href="#syscall-5" title="Link to this heading">¶</a></h3>
<p>Programma di esempio che contiene una funzione che stampa su standard output la
stringa contenuta nell’indirizzo di memoria a cui punta $a0:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>                .data
params_sys5:    .space  8

                .text
print_string:
                sw      $a0, params_sys5(r0)
                daddi   r14, r0, params_sys5
                syscall 5
                jr      r31
</pre></div>
</div>
<p>La seconda riga alloca spazio per la stringa che sarà stampata dalla SYSCALL,
che è riempito dalla prima istruzione della sezione .text, che assume che
l’indirizzo della stringa da stampare sia in $a0.</p>
<p>L’istruzione successiva salva in r14 l’indirizzo di questa stringa, e
successivamente la SYSCALL 5 viene chiamata, stampando quindi la stringa.
L’ultima istruzione varia il program counter, impostandolo al valore di r31 -
che secondo le convenzioni di chiamata di funzione MIPS contiene l’indirizzo
dell’istruzione successiva alla chiamata di funzione.</p>
</section>
<section id="un-esempio-di-utilizzo-della-syscall-5-piu-complesso">
<h3>Un esempio di utilizzo della SYSCALL 5 più complesso<a class="headerlink" href="#un-esempio-di-utilizzo-della-syscall-5-piu-complesso" title="Link to this heading">¶</a></h3>
<p>La SYSCALL 5 utilizza un meccanismo di passaggio parametri non semplicissimo,
che sarà illustrato nel seguente esempio:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>                <span class="o">.</span><span class="n">data</span>
<span class="n">format_str</span><span class="p">:</span>     <span class="o">.</span><span class="n">asciiz</span>   <span class="s2">&quot;</span><span class="si">%d</span><span class="s2"> </span><span class="si">%s</span><span class="s2">:</span><span class="se">\n</span><span class="s2">Test di </span><span class="si">%s</span><span class="s2"> versione </span><span class="si">%i</span><span class="s2">.</span><span class="si">%i</span><span class="s2">!&quot;</span>
<span class="n">s1</span><span class="p">:</span>             <span class="o">.</span><span class="n">asciiz</span>   <span class="s2">&quot;Giugno&quot;</span>
<span class="n">s2</span><span class="p">:</span>             <span class="o">.</span><span class="n">asciiz</span>   <span class="s2">&quot;EduMIPS64&quot;</span>
<span class="n">fs_addr</span><span class="p">:</span>        <span class="o">.</span><span class="n">space</span>    <span class="mi">4</span>
                <span class="o">.</span><span class="n">word</span>     <span class="mi">5</span>
<span class="n">s1_addr</span><span class="p">:</span>        <span class="o">.</span><span class="n">space</span>    <span class="mi">4</span>
<span class="n">s2_addr</span><span class="p">:</span>        <span class="o">.</span><span class="n">space</span>    <span class="mi">4</span>
                <span class="o">.</span><span class="n">word</span>     <span class="mi">0</span>
                <span class="o">.</span><span class="n">word</span>     <span class="mi">5</span>
<span class="n">test</span><span class="p">:</span>
                <span class="o">.</span><span class="n">code</span>
                <span class="n">daddi</span>     <span class="n">r5</span><span class="p">,</span> <span class="n">r0</span><span class="p">,</span> <span class="n">format_str</span>
                <span class="n">sw</span>        <span class="n">r5</span><span class="p">,</span> <span class="n">fs_addr</span><span class="p">(</span><span class="n">r0</span><span class="p">)</span>
                <span class="n">daddi</span>     <span class="n">r2</span><span class="p">,</span> <span class="n">r0</span><span class="p">,</span> <span class="n">s1</span>
                <span class="n">daddi</span>     <span class="n">r3</span><span class="p">,</span> <span class="n">r0</span><span class="p">,</span> <span class="n">s2</span>
                <span class="n">sd</span>        <span class="n">r2</span><span class="p">,</span> <span class="n">s1_addr</span><span class="p">(</span><span class="n">r0</span><span class="p">)</span>
                <span class="n">sd</span>        <span class="n">r3</span><span class="p">,</span> <span class="n">s2_addr</span><span class="p">(</span><span class="n">r0</span><span class="p">)</span>
                <span class="n">daddi</span>     <span class="n">r14</span><span class="p">,</span> <span class="n">r0</span><span class="p">,</span> <span class="n">fs_addr</span>
                <span class="n">syscall</span>   <span class="mi">5</span>
                <span class="n">syscall</span>   <span class="mi">0</span>
</pre></div>
</div>
<p>L’indirizzo di memoria della stringa di formato viene inserito in R5, il cui
contenuto viene quindi salvato in memoria all’indirizzo <cite>fs_addr</cite>. Gli
indirizzi dei parametri di tipo stringa sono salvato in <cite>s1_addr</cite> ed
<cite>s2_addr</cite>. Questi due parametri saranno inseriti al posto dei due segnaposto
<cite>%s</cite> all’interno della stringa di formato.</p>
<p>Nel caso di stringhe di formato complesse, come mostrato da questo esempio, le
word che corrispondono ai segnaposto vanno inserite in memoria subito dopo
l’indirizzo della stringa di formato.</p>
</section>
</section>
</section>


            <div class="clearer"></div>
          </div>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
  </body>
</html>