

<html lang="zh" data-content_root="./">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" /><meta name="viewport" content="width=device-width, initial-scale=1" />

    <title>代码示例 &#8212; EduMIPS64 1.3.0 文档</title>
    <link rel="stylesheet" type="text/css" href="_static/pygments.css?v=03e43079" />
    <link rel="stylesheet" type="text/css" href="_static/epub.css?v=e4d0adb4" />
    <script src="_static/documentation_options.js?v=6acfd120"></script>
    <script src="_static/doctools.js?v=9bcbadda"></script>
    <script src="_static/sphinx_highlight.js?v=dc90522c"></script> 
  </head><body>

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            
  <section id="id1">
<h1>代码示例<a class="headerlink" href="#id1" title="Link to this heading">¶</a></h1>
<p>在本章中，您将看到一些对理解 EduMIPS64 如何工作非常有用的示例列表，以了解 EduMIPS64 如何工作。</p>
<section id="syscall">
<h2>SYSCALL<a class="headerlink" href="#syscall" title="Link to this heading">¶</a></h2>
<p>重要的是要了解 SYSCALL 1-4 的示例引用了`print.s` 文件，这是 SYSCALL 5 的示例。如果要运行
示例，应将该示例的内容复制到一个名为`print.s` 的文件，并将其包含在代码中。</p>
<p>有些示例会使用已存在的文件描述符，即使它并不真正存在。如果要运行这些示例，请使用 SYSCALL 1 示例打开一个文件。</p>
<section id="syscall-0">
<h3>SYSCALL 0<a class="headerlink" href="#syscall-0" title="Link to this heading">¶</a></h3>
<p>调用 SYSCALL 0 时，程序停止执行。
示例:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="o">.</span><span class="n">code</span>
    <span class="n">daddi</span>   <span class="n">r1</span><span class="p">,</span> <span class="n">r0</span><span class="p">,</span> <span class="mi">0</span>    <span class="p">;</span> <span class="n">saves</span> <span class="mi">0</span> <span class="ow">in</span> <span class="n">R1</span>
    <span class="n">syscall</span> <span class="mi">0</span>            <span class="p">;</span> <span class="n">exits</span>
</pre></div>
</div>
</section>
<section id="syscall-1">
<h3>SYSCALL 1<a class="headerlink" href="#syscall-1" title="Link to this heading">¶</a></h3>
<p>打开文件的示例程序:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>                .data
error_op:       .asciiz     &quot;Error opening the file&quot;
ok_message:     .asciiz     &quot;All right&quot;
params_sys1:    .asciiz     &quot;filename.txt&quot;
                .word64     0xF

                .text
open:           daddi       r14, r0, params_sys1
                syscall     1
                daddi       $s0, r0, -1
                dadd        $s2, r0, r1
                daddi       $a0,r0,ok_message
                bne         r1,$s0,end
                daddi       $a0,r0,error_op

end:            jal         print_string
                syscall 0

                #include    print.s
</pre></div>
</div>
<p>在前两行中，我们将包含错误信息和成功信息的字符串写入内存，并将其传递给 print_string 函数。
给它们加上两个标签。print_string 函数包含在 print.s 文件中。</p>
<p>接下来，我们向内存写入 SYSCALL 1 所需的数据（第 4、5 行）、要打开的文件的路径（第 6、7 行
要打开的文件的路径（如果我们使用 读取 或 读/写模式），并在下一个内存单元中写入一个定义打开模式的整数。</p>
<p>在本例中，文件使用以下模式打开：
| <cite>o_rdwr</cite> | <cite>o_creat</cite> | <cite>_append</cite>。数字
数字 15（0xF，以 16 为基数）来自这三种模式的值之和（3 + 4 + 8）。</p>
<p>我们给这些数据加上一个标签，以便以后使用。</p>
<p>在 .text 部分，我们将 params_sys1 的地址（对编译器来说是一个数字）保存在寄存器中。
在 .text 部分，我们将 params_sys1 的地址（对编译器来说是一个数字）保存在寄存器 r14 中；接下来我们可以调用 SYSCALL 1 并将 r1 的内容保存在 $sys1 中。
将 r1 的内容保存在 $s2 中，这样我们就可以在程序的其余部分中使用它了
（例如，使用其他 SYSCALL）。</p>
<p>然后调用 print_string 函数，将 error_op 作为参数传递，如果
r1等于-1（第 13-14 行），否则将 ok_message 作为参数（第 12 和 14 行）。
则将 ok_message 作为参数（第 12 和 16 行）。</p>
</section>
<section id="syscall-2">
<h3>SYSCALL 2<a class="headerlink" href="#syscall-2" title="Link to this heading">¶</a></h3>
<p>关闭文件的示例程序:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>                .data
params_sys2:    .space 8
error_cl:       .asciiz     &quot;Error closing the file&quot;
ok_message:     .asciiz     &quot;All right&quot;

                .text
close:          daddi       r14, r0, params_sys2
                sw          $s2, params_sys2(r0)
                syscall     2
                daddi       $s0, r0, -1
                daddi       $a0, r0, ok_message
                bne         r1, $s0, end
                daddi       $a0, r0, error_cl

end:            jal         print_string
                syscall     0

                #include    print.s
</pre></div>
</div>
<p>首先，我们为 SYSCALL 2 的唯一参数，即必须关闭的文件的文件描述符（第 2 行）保存一些内存，并给它一个标签，以便以后访问。</p>
<p>接下来，我们将包含错误信息和成功信息的字符串放入内存，这些字符串将传递给 print_string 函数（第 3、4 行）。</p>
<p>在 .text 部分，我们将 params_sys2 的地址保存在 r14 中；然后我们就可以 调用 SYSCALL 2。</p>
<p>现在我们使用 error_cl 作为参数调用 print_string 函数，如果 r1
则调用 print_string 函数（第 13 行），如果一切顺利，则使用 ok_message 作为参数调用 print_string 函数（第 11 行）。则使用 ok_message 作为参数调用该函数（第 11 行）。</p>
<p><strong>注：</strong> 此列表需要寄存器 $s2 包含要调用的文件的文件描述符。文件描述符。</p>
</section>
<section id="syscall-3">
<h3>SYSCALL 3<a class="headerlink" href="#syscall-3" title="Link to this heading">¶</a></h3>
<p>从文件读取 16 个字节并保存到内存的示例程序:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>                .data
params_sys3:    .space      8
ind_value:      .space      8
                .word64     16
error_3:        .asciiz     &quot;Error while reading from file&quot;
ok_message:     .asciiz     &quot;All right&quot;

value:          .space      30

                .text
read:           daddi       r14, r0, params_sys3
                sw          $s2, params_sys3(r0)
                daddi       $s1, r0, value
                sw          $s1, ind_value(r0)
                syscall     3
                daddi       $s0, r0, -1
                daddi       $a0, r0,ok_message
                bne         r1, $s0,end
                daddi       $a0, r0,error_3

end:            jal         print_string
                syscall     0

                #include    print.s
</pre></div>
</div>
<p>.data 部分的前 4 行包含 SYSCALL 3 的参数、我们必须从中读取的文件描述符、SYSCALL 必须保存读取数据的内存地址以及要读取的字节数。我们给那些稍后必须访问的参数加上标签。接下来，像往常一样，我们将包含错误信息和成功信息的字符串放入其中。</p>
<p>在 .text 部分，我们将 params_sys3 的地址保存到寄存器 r14 中，并在 SYSCALL 参数的内存单元中保存文件描述符（我们假设保存在 $s2 中）和用于保存读取字节的地址。</p>
<p>接下来，我们可以调用 SYSCALL 3，然后调用 print_string 函数
根据操作成功与否，将 error_3 或 ok_message 作为参数传递。</p>
</section>
<section id="syscall-4">
<h3>SYSCALL 4<a class="headerlink" href="#syscall-4" title="Link to this heading">¶</a></h3>
<p>向文件写入字符串的示例程序:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>                .data
params_sys4:    .space      8
ind_value:      .space      8
                .word64     16
error_4:        .asciiz     &quot;Error writing to file&quot;
ok_message:     .asciiz     &quot;All right&quot;
value:          .space      30

                .text

write:          daddi       r14, r0,params_sys4
                sw          $s2, params_sys4(r0)
                daddi       $s1, r0,value
                sw          $s1, ind_value(r0)
                syscall     4
                daddi       $s0, r0,-1
                daddi       $a0, r0,ok_message
                bne         r1, $s0,end
                daddi       $a0, r0,error_4

end:            jal         print_string
                syscall     0

                #include    print.s
</pre></div>
</div>
<p>.data 部分的前 4 行包含 SYSCALL 4 的参数、我们必须读取的文件描述符、SYSCALL 必须读取的内存地址、要写入的字节数。我们给那些稍后必须访问的参数加上标签。接下来，像往常一样，我们将包含错误信息和成功信息的字符串放入其中。</p>
<p>在 .text 部分，我们将 params_sys4 的地址保存到寄存器 r14 中，在 SYSCALL 参数的内存单元中保存文件描述符（我们假设保存在 $s2 中）和我们必须读取写入字节的地址。</p>
<p>接下来我们可以调用 SYSCALL 3，然后根据操作的成功与否调用 print_string 函数，参数为 error_3 或 ok_message。</p>
</section>
<section id="syscall-5">
<h3>SYSCALL 5<a class="headerlink" href="#syscall-5" title="Link to this heading">¶</a></h3>
<p>包含将 $a0 中的字符串打印到标准输出的函数的示例程序:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>                .data
params_sys5:    .space  8

                .text
print_string:
                sw      $a0, params_sys5(r0)
                daddi   r14, r0, params_sys5
                syscall 5
                jr      r31
</pre></div>
</div>
<p>第二行用于为 SYSCALL 必须打印的字符串保存空间，由 .text 部分的第一条指令填充，该指令假定 $a0 中有要打印的字符串地址。</p>
<p>下一条指令将字符串的地址放入 r14，然后我们就可以调用 SYSCALL 5 打印字符串了。最后一条指令将程序计数器设置为 r31 中的内容，这是 MIPS 通常的调用习惯。</p>
</section>
<section id="id2">
<h3>一个更复杂的 SYSCALL 5 使用示例<a class="headerlink" href="#id2" title="Link to this heading">¶</a></h3>
<p>SYSCALL 5 使用了一种并不简单的参数传递机制，下面的示例将对此进行说明:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>                <span class="o">.</span><span class="n">data</span>
<span class="n">format_str</span><span class="p">:</span>     <span class="o">.</span><span class="n">asciiz</span>   <span class="s2">&quot;</span><span class="si">%d</span><span class="s2">th of </span><span class="si">%s</span><span class="s2">:</span><span class="se">\n</span><span class="si">%s</span><span class="s2"> version </span><span class="si">%i</span><span class="s2">.</span><span class="si">%i</span><span class="s2"> is being tested!&quot;</span>
<span class="n">s1</span><span class="p">:</span>             <span class="o">.</span><span class="n">asciiz</span>   <span class="s2">&quot;June&quot;</span>
<span class="n">s2</span><span class="p">:</span>             <span class="o">.</span><span class="n">asciiz</span>   <span class="s2">&quot;EduMIPS64&quot;</span>
<span class="n">fs_addr</span><span class="p">:</span>        <span class="o">.</span><span class="n">space</span>    <span class="mi">4</span>
                <span class="o">.</span><span class="n">word</span>     <span class="mi">5</span>
<span class="n">s1_addr</span><span class="p">:</span>        <span class="o">.</span><span class="n">space</span>    <span class="mi">4</span>
<span class="n">s2_addr</span><span class="p">:</span>        <span class="o">.</span><span class="n">space</span>    <span class="mi">4</span>
                <span class="o">.</span><span class="n">word</span>     <span class="mi">0</span>
                <span class="o">.</span><span class="n">word</span>     <span class="mi">5</span>
<span class="n">test</span><span class="p">:</span>
                <span class="o">.</span><span class="n">code</span>
                <span class="n">daddi</span>     <span class="n">r5</span><span class="p">,</span> <span class="n">r0</span><span class="p">,</span> <span class="n">format_str</span>
                <span class="n">sw</span>        <span class="n">r5</span><span class="p">,</span> <span class="n">fs_addr</span><span class="p">(</span><span class="n">r0</span><span class="p">)</span>
                <span class="n">daddi</span>     <span class="n">r2</span><span class="p">,</span> <span class="n">r0</span><span class="p">,</span> <span class="n">s1</span>
                <span class="n">daddi</span>     <span class="n">r3</span><span class="p">,</span> <span class="n">r0</span><span class="p">,</span> <span class="n">s2</span>
                <span class="n">sd</span>        <span class="n">r2</span><span class="p">,</span> <span class="n">s1_addr</span><span class="p">(</span><span class="n">r0</span><span class="p">)</span>
                <span class="n">sd</span>        <span class="n">r3</span><span class="p">,</span> <span class="n">s2_addr</span><span class="p">(</span><span class="n">r0</span><span class="p">)</span>
                <span class="n">daddi</span>     <span class="n">r14</span><span class="p">,</span> <span class="n">r0</span><span class="p">,</span> <span class="n">fs_addr</span>
                <span class="n">syscall</span>   <span class="mi">5</span>
                <span class="n">syscall</span>   <span class="mi">0</span>
</pre></div>
</div>
<p>格式字符串的地址被放入 R5，其内容随后被保存到内存中的 fs_addr 地址。字符串参数的地址被保存到 s1_addr 和 s2_addr。这两个字符串参数与格式字符串中的两个 %s 占位符相匹配。</p>
<p>从内存来看，与占位符相匹配的参数显然是紧跟在格式字符串地址之后存储的：数字与整数参数相匹配，而地址与字符串参数相匹配。在 s1_addr 和 s2_addr 位置，存放着我们要打印的两个字符串的地址，而不是 %s 占位符。</p>
<p>示例的执行将显示 SYSCALL 5 如何处理复杂的格式字符串，如存储在 format_str 中的字符串。</p>
</section>
</section>
</section>


            <div class="clearer"></div>
          </div>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
  </body>
</html>