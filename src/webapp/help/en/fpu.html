

<html lang="en" data-content_root="./">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" /><meta name="viewport" content="width=device-width, initial-scale=1" />

    <title>Floating Point Unit &#8212; EduMIPS64 1.3.0 documentation</title>
    <link rel="stylesheet" type="text/css" href="_static/pygments.css?v=03e43079" />
    <link rel="stylesheet" type="text/css" href="_static/epub.css?v=e4d0adb4" />
    <script src="_static/documentation_options.js?v=1f29e9d3"></script>
    <script src="_static/doctools.js?v=9bcbadda"></script>
    <script src="_static/sphinx_highlight.js?v=dc90522c"></script> 
  </head><body>

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            
  <section id="floating-point-unit">
<h1>Floating Point Unit<a class="headerlink" href="#floating-point-unit" title="Link to this heading">¶</a></h1>
<p>This chapter <a class="footnote-reference brackets" href="#id2" id="id1" role="doc-noteref"><span class="fn-bracket">[</span>1<span class="fn-bracket">]</span></a> describes the Floating Point Unit (FPU) emulated in
EduMIPS64.</p>
<p>In the first paragraph we introduce the double format, the special floating
point values defined in the IEEE 754 standard and the exceptions that floating
point computations can raise.</p>
<p>In the second paragraph we explain how EduMIPS64 allows users to enable or
disable the IEEE floating point traps.</p>
<p>In the third paragraph we describe how double precision numbers and special
values can be specified in the source programs.</p>
<p>In the fourth paragraph, we introduce the FCSR register, used by the FPU to
represent its state. It contains information about rounding, the boolean
results of comparison operations and the policies for handling IEEE floating
point exceptions.</p>
<p>In the fifth and last paragraph, we present all the MIPS64 floating point
instructions that have been implemented in EduMIPS64.</p>
<p>Before starting the discussion about the FPU, we define the domain of floating
point double precision numbers as [-1.79E308,-4.94E-324] ⋃  {0} ⋃
[4.94E-324,1.79E308].</p>
<aside class="footnote-list brackets">
<aside class="footnote brackets" id="id2" role="doc-footnote">
<span class="label"><span class="fn-bracket">[</span><a role="doc-backlink" href="#id1">1</a><span class="fn-bracket">]</span></span>
<p>This chapter is part of the Bachelor’s degree thesis by Massimo Trubia:
“Progetto e implementazione di un modello di Floating Point Unit per un
simulatore di CPU MIPS64”.</p>
</aside>
</aside>
<section id="special-values">
<span id="id3"></span><h2>Special values<a class="headerlink" href="#special-values" title="Link to this heading">¶</a></h2>
<p>Floating point arithmetics allows the programmer to choose whether to stop the
computation or not, if invalid operations are carried on. In this scenario,
operations like the division between zeroes or square roots of negative
numbers must produce a result that, not being a number (NaN) is treated as
somehting different.</p>
<section id="nan-or-invalid-operation">
<span id="nan"></span><h3>NaN or Invalid Operation<a class="headerlink" href="#nan-or-invalid-operation" title="Link to this heading">¶</a></h3>
<p>The IEEE Standard for Floating-Point Arithmetic (IEEE 754) defined that
invalid arithmetic operations can either signal the error while the program is
running (using a trap for the IEEE exception <strong>Invalid Operation</strong>) or return
as a result the special value QNan (Quit Not a Number). Another NaN value,
that inconditionally raises the same trap once it is detected as being one of
the operands, is SNan (Signalling Not a Number). This value is seldom used in
applications, and historically it has been used to initialize variables.</p>
</section>
<section id="zeroes-or-underflows">
<span id="zeroes"></span><h3>Zeroes or Underflows<a class="headerlink" href="#zeroes-or-underflows" title="Link to this heading">¶</a></h3>
<p>Another special value defined by the standard is zero. Since the double format
does not include the zero in its domain, it is considered a special value.
There is a positive zero and a negative zero: the former is used when a
representation of a negative number ∈ ]-4.94E-324,0[) is attempted, and a
result is required (as opposed to allowing an <strong>Underflow</strong> trap), while the
latter is used when the number that should be represented is ∈  [0,4.94E-324[,
and the Underflow trap is disabled.</p>
</section>
<section id="infinites-or-overflows">
<span id="infinites"></span><h3>Infinites or Overflows<a class="headerlink" href="#infinites-or-overflows" title="Link to this heading">¶</a></h3>
<p>When a program attempts to represent a value with an extremely large absolute
value (∈ ]-∞,-1.79E308[ ⋃ ]1.79E308,+∞[), that is outside the domain of double
values, the CPU returns either -∞ or +∞. The alternative is to trigger a trap
for the exceptional <strong>Overflow</strong> condition.</p>
<p>Infinites can also be returned in case of a division by zero; in that case the
sign of the infinite is given by the product of the sign of the zero and the
sign of the dividend. The <strong>Divide by zero</strong> trap can be alternatively raised.</p>
</section>
</section>
<section id="exception-configuration">
<span id="id4"></span><h2>Exception configuration<a class="headerlink" href="#exception-configuration" title="Link to this heading">¶</a></h2>
<p>EduMIPS64 allows the user to enable or disable the traps for 4 of the 5 IEEE
exceptions, through the <em>FPU Exceptions</em> tab in the <em>Configure</em> → <em>Settings</em>
window. If any of them is disabled, the respective special value will be
returned (as described in <a class="reference internal" href="#special-values"><span class="std std-ref">Special values</span></a>).</p>
</section>
<section id="the-double-directive">
<span id="double-directive"></span><h2>The .double directive<a class="headerlink" href="#the-double-directive" title="Link to this heading">¶</a></h2>
<p>The <code class="docutils literal notranslate"><span class="pre">.double</span></code> directive must be used in the <code class="docutils literal notranslate"><span class="pre">.data</span></code> section of source
files, and allows to allocate a memory cell for a <em>double</em> value.</p>
<p>The directive can be used in 2 ways:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">variable</span><span class="o">-</span><span class="n">name</span><span class="p">:</span> <span class="o">.</span><span class="n">double</span> <span class="n">double_number</span>
<span class="n">variable</span><span class="o">-</span><span class="n">name</span><span class="p">:</span> <span class="o">.</span><span class="n">double</span> <span class="n">keyword</span>
</pre></div>
</div>
<p>where <code class="docutils literal notranslate"><span class="pre">double_number</span></code> can be represented either in extended notation
(<code class="docutils literal notranslate"><span class="pre">1.0,0.003</span></code>), or in scientific notation(<code class="docutils literal notranslate"><span class="pre">3.7E-12,0.5E32</span></code>).
<code class="docutils literal notranslate"><span class="pre">keyword</span></code> can be <code class="docutils literal notranslate"><span class="pre">POSITIVEINFINITY</span></code>, <code class="docutils literal notranslate"><span class="pre">NEGATIVEINFINITY</span></code>,
<code class="docutils literal notranslate"><span class="pre">POSITIVEZERO</span></code>, <code class="docutils literal notranslate"><span class="pre">NEGATIVEZERO</span></code>, <code class="docutils literal notranslate"><span class="pre">SNAN</span></code> e <code class="docutils literal notranslate"><span class="pre">QNAN</span></code>,
thus allowing to directly insert in memory the special values.</p>
</section>
<section id="the-fcsr-register">
<h2>The FCSR register<a class="headerlink" href="#the-fcsr-register" title="Link to this heading">¶</a></h2>
<p>The FCSR (Floating point Control Status Register) is the register that
controls several functional aspects of the FPU. It is 32 bits long and it is
represented in the statistics window.</p>
<p>The <strong>FCC</strong> field is 8 bits wide, from 0 to 7. The conditional instructions
(<code class="docutils literal notranslate"><span class="pre">C.EQ.D,C.LT.D</span></code>) use it to save the boolean result of comparisons between
two registers.</p>
<p>The Cause, Enables and Flag fields handle the dynamics of IEEE exceptions
described in <a class="reference internal" href="#special-values"><span class="std std-ref">Special values</span></a>. Each of them is composed of 5 bits, V
(Invalid Operation), Z (Divide by Zero), O (Overflow), U (Underflow) and I
(Inexact); the latter is not yet used.</p>
<p>The <strong>Clause</strong> field bits are set if the corresponding IEEE exceptions occur
during the execution of a program.</p>
<p>The <strong>Enable</strong> field bits are set through the configuration window and show
the IEEE exceptions for which traps are enabled.</p>
<p>The <strong>Flag</strong> field shows the exceptions that have happened but, since the trap
is not enabled for that particular exception, have returned special values
(the ones described in <a class="reference internal" href="#special-values"><span class="std std-ref">Special values</span></a>).</p>
<p>The <strong>RM</strong> field describes the rounding method currently in use to convert
floating point numbers to integers (see the description of the <code class="docutils literal notranslate"><span class="pre">CVT.L.D</span></code>
instruction).</p>
</section>
<section id="instruction-set">
<h2>Instruction set<a class="headerlink" href="#instruction-set" title="Link to this heading">¶</a></h2>
<p>This section describes the MIPS64 FPU instruction implemented by EduMIPS64;
they are listed in alphabetic order. The operations performed by the
instruction are described using a notation according to which the i-th
memory cell is represented as <code class="docutils literal notranslate"><span class="pre">memory[i]</span></code>, and the FCC fields of the FCSR
register are <code class="docutils literal notranslate"><span class="pre">FCSR_FCC[cc]</span></code>, <code class="docutils literal notranslate"><span class="pre">cc</span></code> ∈ [0,7].</p>
<p>In some instructions, to avoid ambiguity, the registers are represented as
<code class="docutils literal notranslate"><span class="pre">GPR[i]</span></code> and <code class="docutils literal notranslate"><span class="pre">FPR[i]</span></code>, <code class="docutils literal notranslate"><span class="pre">i</span></code> ∈ [0,31], but in most cases we just use the
<code class="docutils literal notranslate"><span class="pre">rx</span></code> or <code class="docutils literal notranslate"><span class="pre">fx</span></code> notation, with <code class="docutils literal notranslate"><span class="pre">x</span></code> ∈ {d,s,t}. The three letters are used to
indicate the purpose of each register (destination, source, third). Lastly,
the values returned by conversion operations are represented with the
following notation: <code class="docutils literal notranslate"><span class="pre">convert_conversiontype(register[,rounding_type])</span></code>,
where the <code class="docutils literal notranslate"><span class="pre">rounding_type</span></code> parameter is optional.</p>
<p>Some examples for the FPU instructions are available at
<code class="docutils literal notranslate"><span class="pre">http://www.edumips.org/attachment/wiki/Upload/FPUMaxSamples.rar</span></code>.</p>
<ul>
<li><p><cite>ADD.D fd, fs, ft</cite></p>
<p><em>Description</em>: <code class="docutils literal notranslate"><span class="pre">fd</span> <span class="pre">=</span> <span class="pre">fs</span> <span class="pre">+</span> <span class="pre">ft</span></code></p>
<p><em>Exceptions</em>: Overflow and underflow traps are generated if the result
cannot be represented according to IEEE 754. Invalid operation is raised if
fs or ft contain QNaN or SNan, or if an invalid operation (+∞ - ∞) is
executed.</p>
</li>
<li><p><cite>BC1F cc, offset</cite></p>
<p><em>Description</em>: <code class="docutils literal notranslate"><span class="pre">if</span> <span class="pre">FCSR_FCC[cc]</span> <span class="pre">==</span> <span class="pre">0</span> <span class="pre">then</span> <span class="pre">branch</span></code></p>
<p>If <code class="docutils literal notranslate"><span class="pre">FCSR_FCC[cc]</span></code> is false, do a PC-relative branch.</p>
<p><em>Example</em>:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">C</span><span class="o">.</span><span class="n">EQ</span><span class="o">.</span><span class="n">D</span> <span class="mi">7</span><span class="p">,</span><span class="n">f1</span><span class="p">,</span><span class="n">f2</span>
<span class="n">BC1F</span> <span class="mi">7</span><span class="p">,</span><span class="n">label</span>
</pre></div>
</div>
<p>In this example, <code class="docutils literal notranslate"><span class="pre">C.EQ.D</span></code> checks if <code class="docutils literal notranslate"><span class="pre">f1</span></code> and <code class="docutils literal notranslate"><span class="pre">f2</span></code> are equal, writing
the results of the comparison in the 7th bit of the FCC field of the FCSR
register. After that, <code class="docutils literal notranslate"><span class="pre">BC1F</span></code> jumps to <code class="docutils literal notranslate"><span class="pre">label</span></code> if the result of the
comparison is 0 (false).</p>
</li>
<li><p><cite>BC1T cc, offset</cite></p>
<p><em>Description</em>: <code class="docutils literal notranslate"><span class="pre">if</span> <span class="pre">FCSR_FCC[cc]</span> <span class="pre">==</span> <span class="pre">1</span> <span class="pre">then</span> <span class="pre">branch</span></code></p>
<p>If <code class="docutils literal notranslate"><span class="pre">FCSR_FCC[cc]</span></code> is true, do a PC-relative branch.</p>
<p><em>Example</em>:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">C</span><span class="o">.</span><span class="n">EQ</span><span class="o">.</span><span class="n">D</span> <span class="mi">7</span><span class="p">,</span><span class="n">f1</span><span class="p">,</span><span class="n">f2</span>
<span class="n">BC1T</span> <span class="mi">7</span><span class="p">,</span><span class="n">label</span>
</pre></div>
</div>
<p>In this example, <code class="docutils literal notranslate"><span class="pre">C.EQ.D</span></code> checks if <code class="docutils literal notranslate"><span class="pre">f1</span></code> and <code class="docutils literal notranslate"><span class="pre">f2</span></code> are equal, writing
the results of the comparison in the 7th bit of the FCC field of the FCSR
register. After that, <code class="docutils literal notranslate"><span class="pre">BC1F</span></code> jumps to <code class="docutils literal notranslate"><span class="pre">label</span></code> if the result of the
comparison is 1 (false).</p>
</li>
<li><p><cite>C.EQ.D cc, fs, ft</cite></p>
<p><em>Description</em>: <code class="docutils literal notranslate"><span class="pre">FCSR_FCC[cc]</span> <span class="pre">=</span> <span class="pre">(fs==ft)</span></code></p>
<p>Checks if <code class="docutils literal notranslate"><span class="pre">fs</span></code> is equal to <code class="docutils literal notranslate"><span class="pre">ft</span></code>, and saves the result of the comparison
in <code class="docutils literal notranslate"><span class="pre">FCSR_FCC[cc]</span></code>. See examples for <code class="docutils literal notranslate"><span class="pre">BC1T</span></code>, <code class="docutils literal notranslate"><span class="pre">BC1F</span></code>.</p>
<p><em>Exceptions</em>: Invalid Operation can be thrown if <code class="docutils literal notranslate"><span class="pre">fs</span></code> or <code class="docutils literal notranslate"><span class="pre">ft</span></code> contain
QNaN (trap is triggered if it is enabled) o SNaN (trap is always triggered).</p>
</li>
<li><p><cite>C.LT.D cc, fs, ft</cite></p>
<p><em>Description</em>: <code class="docutils literal notranslate"><span class="pre">FCSR_FCC[cc]</span> <span class="pre">=</span> <span class="pre">(fs&lt;ft)</span></code></p>
<p>Checks if <code class="docutils literal notranslate"><span class="pre">fs</span></code> is smaller than <code class="docutils literal notranslate"><span class="pre">ft</span></code>, and saves the result of the
comparison in <code class="docutils literal notranslate"><span class="pre">FCSR_FCC[cc]</span></code>.</p>
<p><em>Example</em>:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">C</span><span class="o">.</span><span class="n">LT</span><span class="o">.</span><span class="n">D</span> <span class="mi">2</span><span class="p">,</span><span class="n">f1</span><span class="p">,</span><span class="n">f2</span>
<span class="n">BC1T</span> <span class="mi">2</span><span class="p">,</span><span class="n">target</span>
</pre></div>
</div>
<p>In this example, <code class="docutils literal notranslate"><span class="pre">C.LT.D</span></code> checks if <code class="docutils literal notranslate"><span class="pre">f1</span></code> is smaller than <code class="docutils literal notranslate"><span class="pre">f2</span></code>, and
saves the result of the comparison in the second bit of the FCC field of the
FCSR register. After that, <code class="docutils literal notranslate"><span class="pre">BC1T</span></code> jumps to <code class="docutils literal notranslate"><span class="pre">target</span></code> if that bit is set
to 1.</p>
<p><em>Exceptions</em>: Invalid Operation can be thrown if <code class="docutils literal notranslate"><span class="pre">fs</span></code> or <code class="docutils literal notranslate"><span class="pre">ft</span></code> contain
QNaN (trap is triggered if it is enabled) o SNaN (trap is always triggered).</p>
</li>
<li><p><cite>CVT.D.L fd, fs</cite></p>
<p><em>Description</em>: <code class="docutils literal notranslate"><span class="pre">fd</span> <span class="pre">=</span> <span class="pre">convert_longToDouble(fs)</span></code></p>
<p>Converts a long to a double.</p>
<p><em>Example</em>:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">DMTC1</span> <span class="n">r6</span><span class="p">,</span><span class="n">f5</span>
<span class="n">CVT</span><span class="o">.</span><span class="n">D</span><span class="o">.</span><span class="n">L</span> <span class="n">f5</span><span class="p">,</span><span class="n">f5</span>
</pre></div>
</div>
<p>In this example, <code class="docutils literal notranslate"><span class="pre">DMTC1</span></code> copies the value of GPR r6 to FPR f5; after that
<code class="docutils literal notranslate"><span class="pre">CVT.D.L</span></code> converts the value stored in f5 from long to double. If for
instance r6 contains the value 52, after the execution of <code class="docutils literal notranslate"><span class="pre">DMTC1</span></code> the
binary representation of 52 gets copied to f5. After the execution of
<code class="docutils literal notranslate"><span class="pre">CVT.D.L</span></code>, f5 contains the IEEE 754 representation of 52.0.</p>
<p><em>Exceptions:</em> Invalid Operation is thrown if fs contains QNaN, SNaN or an
infinite.</p>
</li>
<li><p><cite>CVT.D.W fd, fs</cite></p>
<p><em>Description:</em> <code class="docutils literal notranslate"><span class="pre">fd</span> <span class="pre">=</span> <span class="pre">convert_IntToDouble(fs)</span></code></p>
<p>Converts an int to a double.</p>
<p><em>Example</em>:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">MTC1</span> <span class="n">r6</span><span class="p">,</span><span class="n">f5</span>
<span class="n">CVT</span><span class="o">.</span><span class="n">D</span><span class="o">.</span><span class="n">W</span> <span class="n">f5</span><span class="p">,</span><span class="n">f5</span>
</pre></div>
</div>
<p>In this example, <code class="docutils literal notranslate"><span class="pre">MTC1</span></code> copies the lower 32 bit of the GPR r6 into the FPR
f5. Then, <code class="docutils literal notranslate"><span class="pre">CVT.D.W</span></code>, reads f5 as an int, and converts it to double.</p>
<p>If we had <code class="docutils literal notranslate"><span class="pre">r6=0xAAAAAAAABBBBBBBB</span></code>, after the execution of  <code class="docutils literal notranslate"><span class="pre">MTC1</span></code> we get
<code class="docutils literal notranslate"><span class="pre">f5=0xXXXXXXXXBBBBBBBB</span></code>; its upper 32 bits (<code class="docutils literal notranslate"><span class="pre">XX..X</span></code>) are now UNDEFINED
(haven’t been overwritten). <code class="docutils literal notranslate"><span class="pre">CVT.D.W</span></code> interprets f5 as an int
(<code class="docutils literal notranslate"><span class="pre">f5=-1145324613</span></code>), and converts it to double(<code class="docutils literal notranslate"><span class="pre">f5=0xC1D1111111400000</span>
<span class="pre">=-1.145324613E9</span></code>).</p>
<p><em>Exceptions:</em> Invalid Operation is thrown if fs contains QNaN, SNaN or an
infinite.</p>
</li>
<li><p><cite>CVT.L.D fd, fs</cite></p>
<p><em>Description:</em> <code class="docutils literal notranslate"><span class="pre">fd</span> <span class="pre">=</span> <span class="pre">convert_doubleToLong(fs,</span> <span class="pre">CurrentRoundingMode)</span></code></p>
<p>Converts a double to a long, rounding it before the conversion.</p>
<p><em>Example</em>:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">CVT</span><span class="o">.</span><span class="n">L</span><span class="o">.</span><span class="n">D</span> <span class="n">f5</span><span class="p">,</span><span class="n">f5</span>
<span class="n">DMFC1</span> <span class="n">r6</span><span class="p">,</span><span class="n">f5</span>
</pre></div>
</div>
<p><code class="docutils literal notranslate"><span class="pre">CVT.L.D</span></code> the double value in f5 to a long; then <code class="docutils literal notranslate"><span class="pre">DMFC1</span></code> copies f5 to
r6; the result of this operation depends on the current rounding modality,
that can be set in the <em>FPU Rounding</em> tab of the <em>Configure</em> →  <em>Settings</em>
window.</p>
</li>
</ul>
<table class="docutils align-default" id="id5">
<caption><span class="caption-text">Rounding examples</span><a class="headerlink" href="#id5" title="Link to this table">¶</a></caption>
<thead>
<tr class="row-odd"><th class="head"><p>Tipo</p></th>
<th class="head"><p>RM field</p></th>
<th class="head"><p>f5 register</p></th>
<th class="head"><p>r6 register</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>To nearest</p></td>
<td><p>0</p></td>
<td><p>6.4</p></td>
<td><p>6</p></td>
</tr>
<tr class="row-odd"><td><p>To nearest</p></td>
<td><p>0</p></td>
<td><p>6.8</p></td>
<td><p>7</p></td>
</tr>
<tr class="row-even"><td><p>To nearest</p></td>
<td><p>0</p></td>
<td><p>6.5</p></td>
<td><p>6 (to even)</p></td>
</tr>
<tr class="row-odd"><td><p>To nearest</p></td>
<td><p>0</p></td>
<td><p>7.5</p></td>
<td><p>8 (to even)</p></td>
</tr>
<tr class="row-even"><td><p>Towards  0</p></td>
<td><p>1</p></td>
<td><p>7.1</p></td>
<td><p>7</p></td>
</tr>
<tr class="row-odd"><td><p>Towards  0</p></td>
<td><p>1</p></td>
<td><p>-2.3</p></td>
<td><p>-2</p></td>
</tr>
<tr class="row-even"><td><p>Towards  ∞</p></td>
<td><p>2</p></td>
<td><p>4.2</p></td>
<td><p>5</p></td>
</tr>
<tr class="row-odd"><td><p>Towards  ∞</p></td>
<td><p>2</p></td>
<td><p>-3.9</p></td>
<td><p>-3</p></td>
</tr>
<tr class="row-even"><td><p>Towards -∞</p></td>
<td><p>3</p></td>
<td><p>4.2</p></td>
<td><p>4</p></td>
</tr>
<tr class="row-odd"><td><p>Towards -∞</p></td>
<td><p>3</p></td>
<td><p>-3.9</p></td>
<td><p>-4</p></td>
</tr>
</tbody>
</table>
<ul>
<li><p><cite>CVT.W.D fd, fs</cite></p>
<p><em>Description:</em> <code class="docutils literal notranslate"><span class="pre">fd</span> <span class="pre">=</span> <span class="pre">convert_DoubleToInt(fs,</span> <span class="pre">CurrentRoundingMode)</span></code></p>
<p>Converts a double to an int, using the current rounding modality.</p>
<p><em>Exceptions:</em> Invalid Operation is thrown if fs contains an infinite value,
any NaN or the results is outside the signed int domain [-2 <sup>63</sup>, 2
<sup>63</sup> -1]</p>
</li>
<li><p><cite>DIV.D fd, fs, ft</cite></p>
<p><em>Description:</em> <code class="docutils literal notranslate"><span class="pre">fd</span> <span class="pre">=</span> <span class="pre">fs</span> <span class="pre">\div</span> <span class="pre">ft</span></code></p>
<p><em>Exceptions:</em> Overflow or Underflow are raised if the results cannot be
represented using the IEEE 754 standard. Invalid Operation is raised if fs
or ft contain QNaN or SNan, or if an invalid operation is executed (0div0,∞
div ∞). Divide by zero is raised if a division by zero is attempted with a
dividend that is not QNaN or SNaN.</p>
</li>
<li><p><cite>DMFC1 rt,fs</cite></p>
<p><em>Description:</em> <code class="docutils literal notranslate"><span class="pre">rt</span> <span class="pre">=</span> <span class="pre">fs</span></code></p>
<p>Executes a bit per bit copy of the FPR fs into the GPR rt.</p>
</li>
<li><p><cite>DMTC1 rt, fs</cite></p>
<p><em>Description:</em> <code class="docutils literal notranslate"><span class="pre">fs</span> <span class="pre">=</span> <span class="pre">rt</span></code></p>
<p>Executes a bit per bit copy of the GPR rt into the FPR fs.</p>
</li>
<li><p><cite>L.D ft, offset(base)</cite></p>
<p><em>Description:</em> <code class="docutils literal notranslate"><span class="pre">ft</span> <span class="pre">=</span> <span class="pre">memory[GPR[base]</span> <span class="pre">+</span> <span class="pre">offset]</span></code></p>
<p>Loads from memory a doubleword and stores it in ft.</p>
</li>
</ul>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p><cite>L.D</cite> is not present in the MIPS64 ISA, it is an alias for <code class="docutils literal notranslate"><span class="pre">LDC1</span></code>
that is present in EduMIPS64 for compatibility with WinMIPS64.</p>
</div>
<ul>
<li><p><cite>LDC1 ft, offset(base)</cite></p>
<p><em>Description:</em> <code class="docutils literal notranslate"><span class="pre">memory[GPR[base]</span> <span class="pre">+</span> <span class="pre">offset]</span></code></p>
<p>Loads from memory a doubleword and stores it in ft.</p>
</li>
<li><p><cite>LWC1 ft, offset(base)</cite></p>
<p><em>Description:</em> <code class="docutils literal notranslate"><span class="pre">ft</span> <span class="pre">=</span> <span class="pre">memory[GPR[base]</span> <span class="pre">+</span> <span class="pre">offset]</span></code></p>
<p>Loads from memory a word and stores it in ft.</p>
</li>
<li><p><cite>MFC1 rt, fs</cite></p>
<p><em>Description:</em> <code class="docutils literal notranslate"><span class="pre">rt</span> <span class="pre">=</span> <span class="pre">readInt(fs)</span></code></p>
<p>Reads the fs FPR as an int and writes its value to the rt GPR as long.
<em>Example</em>:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">MFC1</span> <span class="n">r6</span><span class="p">,</span><span class="n">f5</span>
<span class="n">SD</span> <span class="n">r6</span><span class="p">,</span><span class="n">mem</span><span class="p">(</span><span class="n">R0</span><span class="p">)</span>
</pre></div>
</div>
<p>Let <code class="docutils literal notranslate"><span class="pre">f5=0xAAAAAAAABBBBBBBB</span></code>; <code class="docutils literal notranslate"><span class="pre">MFC1</span></code> reads f5 as an int (lower 32 bits),
interpreting <code class="docutils literal notranslate"><span class="pre">BBBBBBBB</span></code> as <code class="docutils literal notranslate"><span class="pre">-1145324613</span></code>, and writes the value to f6
(64 bits). After the execution of <code class="docutils literal notranslate"><span class="pre">MFC1</span></code>, <code class="docutils literal notranslate"><span class="pre">r6=0xFFFFFFFFBBBBBBBB</span> <span class="pre">=</span>
<span class="pre">-1145324613</span></code>.
So the <code class="docutils literal notranslate"><span class="pre">SD</span></code> instruction will write to memory a doubleword with this value,
since the sign in r6 was extended.</p>
</li>
<li><p><cite>MOVF.D fd, fs, cc</cite></p>
<p><em>Description:</em> <code class="docutils literal notranslate"><span class="pre">if</span> <span class="pre">FCSR_FCC[cc]</span> <span class="pre">==</span> <span class="pre">0</span> <span class="pre">then</span> <span class="pre">fd=fs</span></code></p>
<p>If FCSR_FCC[cc] is false, the copies fs to fd.</p>
</li>
<li><p><cite>MOVT.D fd, fs, cc</cite></p>
<p><em>Description:</em> <code class="docutils literal notranslate"><span class="pre">if</span> <span class="pre">FCSR_FCC[cc]</span> <span class="pre">==</span> <span class="pre">1</span> <span class="pre">then</span> <span class="pre">fd=fs</span></code></p>
<p>If FCSR_FCC[cc] is true, the copies fs to fd.</p>
</li>
<li><p><cite>MOV.D fd, fs</cite></p>
<p><em>Description:</em> <code class="docutils literal notranslate"><span class="pre">fd</span> <span class="pre">=</span> <span class="pre">fs</span></code></p>
<p>Copies fs to fd.</p>
</li>
<li><p><cite>MOVN.D fd, fs, rt</cite></p>
<p><em>Description:</em> <code class="docutils literal notranslate"><span class="pre">if</span> <span class="pre">rt</span> <span class="pre">!=</span> <span class="pre">0</span> <span class="pre">then</span> <span class="pre">fd=fs</span></code></p>
<p>If rt is not zero, copies fs to fd.</p>
</li>
<li><p><cite>MOVZ.D fd, fs, rt</cite></p>
<p><em>Description:</em> <code class="docutils literal notranslate"><span class="pre">if</span> <span class="pre">rt</span> <span class="pre">==</span> <span class="pre">0</span> <span class="pre">then</span> <span class="pre">fd=fs</span></code></p>
<p>If rt is equal to zero, copies fs to fd.</p>
</li>
</ul>
<ul>
<li><p><cite>MTC1 rt, fs</cite></p>
<p><em>Description:</em> fs = rt <sub>0..31</sub></p>
<p>Copies the lower 32 bit of rt to fs.</p>
<p><em>Example</em>:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">MTC1</span> <span class="n">r6</span><span class="p">,</span><span class="n">f5</span>
</pre></div>
</div>
<p>Let <code class="docutils literal notranslate"><span class="pre">r5=0xAAAAAAAABBBBBBBB</span></code>;  <code class="docutils literal notranslate"><span class="pre">MTC1</span></code> reads the lower 32 bits of r5
copying them to the 32 lower bits of f5. The higher 32 bits of f5 are not
overwritten.</p>
</li>
<li><p><cite>MUL.D fd, fs, ft</cite></p>
<p><em>Description:</em> <code class="docutils literal notranslate"><span class="pre">fd</span> <span class="pre">=</span> <span class="pre">fs</span> <span class="pre">×</span> <span class="pre">ft</span></code></p>
<p><em>Exceptions:</em> Overflow or Underflow are raised if the results cannot be
represented using the IEEE 754 standard. Invalid Operation is raised if fs
or ft contain QNaN or SNan, or if an invalid operation is executed (multiply
by ∞ OR BY QNaN).</p>
</li>
<li><p><cite>S.D ft, offset(base)</cite></p>
<p><em>Description:</em> <code class="docutils literal notranslate"><span class="pre">memory[base+offset]</span> <span class="pre">=</span> <span class="pre">ft</span></code></p>
<p>Copies ft to memory.</p>
</li>
</ul>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p><cite>S.D</cite> is not present in the MIPS64 ISA, it is an alias for <code class="docutils literal notranslate"><span class="pre">SDC1</span></code>
that is present in EduMIPS64 for compatibility with WinMIPS64.</p>
</div>
<ul>
<li><p><cite>SDC1 ft, offset(base)</cite></p>
<p><em>Description:</em> <code class="docutils literal notranslate"><span class="pre">memory[base+offset]</span> <span class="pre">=</span> <span class="pre">ft</span></code></p>
<p>Copies ft to memory.</p>
</li>
<li><p><cite>SUB.D fd, fs, ft</cite></p>
<p><em>Description:</em> <code class="docutils literal notranslate"><span class="pre">fd</span> <span class="pre">=</span> <span class="pre">fs-ft</span></code></p>
<p><em>Exceptions</em>: Overflow and underflow traps are generated if the result
cannot be represented according to IEEE 753. Invalid operation is raised if
fs or ft contain QNaN or SNan, or if an invalid operation (+∞ - ∞) is
executed.</p>
</li>
<li><p><cite>SWC1 ft, offset(base)</cite></p>
<p><em>Description:</em> <code class="docutils literal notranslate"><span class="pre">memory[base+offset]</span> <span class="pre">=</span> <span class="pre">ft</span></code></p>
<p>Copies the lower 32 bits of ft to memory.</p>
</li>
</ul>
</section>
</section>


            <div class="clearer"></div>
          </div>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
  </body>
</html>